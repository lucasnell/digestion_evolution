% updated 1Jun09function MERegREML(data,ME,Vall,bootflag,alpha,reps)global CX CY MX MY nX nY p counter% number of tips and variables[n p]=size(data);Y=data(:,1);X=data(:,2:end);MEY=ME(:,1);MEX=ME(:,2:end);MY=diag(MEY.^2);MX=diag(MEX(:).^2);CY=Vall(:,:,1);CX=[];for i=2:p	Crow=[];	for j=2:p						CXi=Vall(:,:,i);		CXj=Vall(:,:,j);				if sum(sum((CXi-CXj).^2)) < 10^-8			Crow=[Crow CXi];		else			invCXi=CXi\eye(n);			invCXj=CXj\eye(n);			iDXi=chol(CXi)';			iDXj=chol(CXj)';			CXij=iDXi*iDXj';			Crow=[Crow CXij];		end	end	CX=[CX;Crow];end% GLS estimates without measurement errorU=ones(n,1);aX=[];for i=2:p	invCX=Vall(:,:,i)\eye(n);	a=(U'*invCX*U)\(U'*invCX*X(:,i-1));	aX=[aX;a];ends2X=[];for i=2:p	ss2X=[];	for j=2:p		invCXY=CX(n*(i-2)+1:n*(i-1),n*(j-2)+1:n*(j-1))\eye(n);		ss2X=[ss2X (X(:,i-1)-aX(i-1))'*invCXY*(X(:,j-1)-aX(j-1))/(n-1)];	end	s2X=[s2X;ss2X];ends2X=s2X^.5;s2=[];for i=1:p-1	s2=[s2 s2X(i,i:end)];endU2=[ones(n,1) X];invCY=CY\eye(n);b=(U2'*invCY*U2)\(U2'*invCY*Y);s2E=(Y-U2*b)'*invCY*(Y-U2*b)/(n-p);sE=s2E^.5;% REML estimates with measurement erroroptions=optimset('tolX',10^-8,'MaxFunEvals',10^6,'MaxIter',10^6);%passed to MERegREMLfunct.mnX=X;	nY=Y;	startp=[b' sE aX' s2];ii=0;while MERegREMLfunct(startp)>=10^10 & ii <50	ii=ii+1;	s2Xtemp=s2X^2;		dsX=diag(diag(s2Xtemp).^-.5);	R=dsX*s2Xtemp*dsX;	R=R.*(.01*ii*eye(p-1)+(1-.01*ii)*ones(p-1,p-1));		dsX=diag(diag(s2Xtemp).^.5);	temps2X=dsX*R*dsX;		temps2X=temps2X^.5;	s2=[];	for i=1:p-1		s2=[s2 temps2X(i,i:end)];	end	startp=[b' sE aX' s2];endcounter=0;[est LL]=fminsearch('MERegREMLfunct',startp,options);lnlike=-LL - (p*n-length(b))*log(2*pi)/2 + log(det(n^p))/2;b=est(1:p-1)';	sE=abs(est(p));s2=est(2*p+1:end);startboot=est;% extract covariance matrixs2X=zeros(p-1,p-1);ii=1;for i=1:p-1	for j=i:p-1		s2X(i,j)=s2(ii);		ii=ii+1;	endends2X=s2X+s2X'-diag(diag(s2X));s2X=s2X^2;sX=diag(s2X).^.5;ds2X=diag(diag(s2X).^(-.5));R=ds2X*s2X*ds2X;% extract estimates of the meansvX=R.*(sX*sX');VX=CX.*kron(vX,ones(n,n));VX=VX+MX;vXY=vX.*(b*ones(1,p-1));vXY=CX.*kron(vXY,ones(n,n));vYY=vX.*(b*b');vYY=CX.*kron(vYY,ones(n,n));VXY=zeros(n*(p-1),n);VYY=zeros(n,n);for i=1:p-1	VXY=VXY + vXY(:,n*(i-1)+1:n*i);	for j=1:p-1		VYY=VYY + vYY(n*(i-1)+1:n*i,n*(j-1)+1:n*j);	endendVYY=VYY+sE^2*CY+MY;VV=[VX VXY;VXY' VYY];invVV=VV\eye(p*n);Z=kron(eye(p),ones(n,1));w=kron(eye(p),[nX nY]);W=w(:,1:p+1:end);a=(Z'*invVV*Z)\(Z'*invVV*W);a=diag(a);aX=a(1:p-1);aY=a(p);b0=aY-b'*aX;est=[b0 b' sE^2 aX' s2];estR=R;aXtrue=aX;btrue=[b0;b];if bootflag		VX=kron(R.*(sX'*sX),ones(n,n)).*CX;	[TX LX TT]=svd(VX);	DX=TX*LX.^(.5);		VY=s2E*CY;	[TY LY TT]=svd(VY);	DY=TY*LY.^(.5);	bootlist=[];	for t=1:reps		EX=DX*randn(n*(p-1),1);		EY=DY*randn(n,1);					a=ones(n,1)*aXtrue';		rX=a(:)+EX;		nX=rX+MEX(:).*randn(n*(p-1),1);			rX=reshape(rX,n,p-1);		nX=reshape(nX,n,p-1);		nY=[ones(n,1) rX]*btrue+EY+MEY.*randn(n,1);		counter=0;		[estboot LL]=fminsearch('MERegREMLfunct',startboot,options);		b=estboot(1:p-1)';			sE=abs(estboot(p));		sX=estboot(p+1:2*p-1)';		r=estboot(2*p:end);		% extract correlation matrix		if isempty(r)			R=1;		else			r=(exp(r)-1)./(1+exp(r));				R=zeros(p-1,p-1);			ii=1;			for i=1:p-1				for j=i+1:p-1					R(i,j)=r(ii);					ii=ii+1;				end			end			R=eye(p-1)+R+R';			% constrain R to be positive definite			R=R'*R;			R=R./(diag(R)*diag(R)').^.5;		end		% extract estimates of the means		vX=R.*(sX*sX');		VX=CX.*kron(vX,ones(n,n));		VX=VX+MX;		vXY=vX.*(b*ones(1,p-1));		vXY=CX.*kron(vXY,ones(n,n));		vYY=vX.*(b*b');		vYY=CX.*kron(vYY,ones(n,n));		VXY=zeros(n*(p-1),n);		VYY=zeros(n,n);		for i=1:p-1			VXY=VXY + vXY(:,n*(i-1)+1:n*i);			for j=1:p-1				VYY=VYY + vYY(n*(i-1)+1:n*i,n*(j-1)+1:n*j);			end		end		VYY=VYY+sE^2*CY+MY;		VV=[VX VXY;VXY' VYY];		invVV=VV\eye(p*n);		Z=kron(eye(p),ones(n,1));		w=kron(eye(p),[nX nY]);		W=w(:,1:p+1:end);		a=(Z'*invVV*Z)\(Z'*invVV*W);		a=diag(a);		aX=a(1:p-1);		aY=a(p);		b0=aY-b'*aX;		bootlist=[bootlist;b0 b' sE^2 aX' (sX').^2];	end		% obtain alpha% confidence intervals	[bn, bc]=size(bootlist);	bootconf=[];	for jj=1:bc		d=bootlist(:,jj);		d=sort(d);		m=length(d);		ub=d(ceil((1-.5*alpha)*m));		lb=d(floor(.5*alpha*m));		meand=mean(d);		bootconf=[bootconf; lb meand ub];	endend		% print final valuesif bootflag	fprintf('Coefficients with (lb,mean,ub) from simulation\n')	fprintf(['b0 (intercept) = ',num2str(est(1)),' (',...		num2str(bootconf(1,1)),', ',num2str(bootconf(1,2)),', ',num2str(bootconf(1,3)),')\n']);	for i=1:p-1		fprintf(['b',num2str(i)',' = ',num2str(est(i+1)),' (',...			num2str(bootconf(i+1,1)),', ',num2str(bootconf(i+1,2)),', ',num2str(bootconf(i+1,3)),')\n']);	end		fprintf(['\nsigma2 = ',num2str(est(p+1)),' (',...		num2str(bootconf(p+1,1)),', ',num2str(bootconf(p+1,2)),', ',num2str(bootconf(p+1,3)),')\n\n']);else	fprintf('Coefficients\n')	fprintf(['b0 (intercept) = ',num2str(est(1)),'\n']);	for i=1:p-1		fprintf(['b',num2str(i)',' = ',num2str(est(i+1)),'\n']);	end		fprintf(['\nsigma2 = ',num2str(est(p+1)),'\n\n']);endfprintf('Independent variable means, variances, and correlations\n')for i=1:p-1	fprintf(['aX',num2str(i)',' = ',num2str(est(p+1+i)),'\n']);endfor i=1:p-1	fprintf(['s2X',num2str(i)',' = ',num2str(est(2*p+i)),'\n']);endfor i=1:p-1	for j=i+1:p-1		fprintf(['r(',num2str(i),',',num2str(j)',') = ',num2str(estR(i,j)),'\n']);	endendfprintf(['\nLnLikelihood = ',num2str(lnlike),'\n'])fprintf(['-2LL = ',num2str(-2*lnlike),'\n'])par=length(est)-1-length(b)-length(aX');fprintf(['AIC(par=',num2str(par),') = ',num2str(-2*lnlike + 2*par),'\n\n'])