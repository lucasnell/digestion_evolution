---
title: "Clean CSVs into simpler data frames"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```


This reads the cleaned CSV files with data for individual animals and simplifies 
them into CSV files with means by species and/or intestinal segment.
It needs to be run only once, and not at all if you have the csv files already.

# Summary of output

I created two data sets from morphometric data in `output/clean_morph.csv`:

1. Measurements separated by species (found in `output/tidy_spp.csv`)
2. Measurements separated by species and intestinal segment (`output/tidy_pos.csv`)

I also created one data set each from `output/clean_clearance.csv` and
`output/clean_absorption.csv`.
These csvs are found in `output/tidy_clear.csv` and `output/tidy_absorp.csv`, 
respectively.

Each data set is associated with a set of analyses and only needs certain measurements, 
so only those are included.

The csv files are used in the function `get_df` in the `R/get_data.R` file to 
retrieve a data frame for a given analysis set.
__The analysis sets are as follows\:__

1. `'spp'`: Measurements separated by species.
2. `'pos'`: Measurements by species and position. (You have to also provide the 
   position for this analysis set.)
3. `'clear'`: Clearance data by species. (Uses a different set of individuals entirely
   from the 1–2.)
4. `'absorp'`: Absorption data by species. (Uses a different set of individuals entirely
   from the 1–3.)


For the second analysis set, I need to do the analyses separately for each position 
because modelling within-species and within-individual variance due to position 
rather than process error would be difficult and not likely possible with this small
dataset.



# Getting started

__Load packages\:__
 
```{r packages}
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(magrittr)
    library(purrr)
})
```

# Standard error

The datasets for absorption and clearance need standard error as well as means.

Functions for standard error calculations:

```{r se_funs}
# Calculating standard error
# (The ... is added for compatibility with using alongside mean.)
se <- function(.x, ...) {
    .z <- .x[!is.na(.x)]
    return(sd(.z) / sqrt(length(.z)))
}
# Replacing NAs in a vector of standard errors with the average standard error in 
# that vector.
na_se <- function(.x) {
    .z <- mean(.x, na.rm = TRUE)
    .x[is.na(.x)] <- .z
    return(.x)
}
```



# Full morphometric data frame

This data frame of morphometric measurements will be useful for the next two sections.

```{r morpho}
morph_df <- read_csv('output/clean_morph.csv', col_types = 'cccccddd') %>%
    # Oligoryzomys seems to be the more standard spelling
    mutate(species = ifelse(species == 'Olygoryzomys nigripes', 
                            'Oligoryzomys nigripes', species))

# Number of individuals
N <- morph_df$id %>% unique %>% length

# Measures with no position (i.e., NA in pos column instead of prox, med, or dist)
no_pos <- morph_df %>% 
    filter(is.na(dist)) %>% 
    group_by(measure) %>% 
    summarize(total = n()) %>% 
    filter(total == N) %>% 
    select(measure) %>% 
    unlist %>% 
    paste

# Gathering into 'tall' format, fixing position column, removing spaces from 
# measure column, and changing the "enterocyte_width" measure to "enterocyte_diameter".
morph_df <- morph_df %>% 
    gather(pos, value, prox:dist, na.rm = TRUE) %>% 
    mutate(pos = ifelse(measure %in% no_pos, NA, pos),
           measure = gsub('enterocyte_width', 'enterocyte_diameter', 
                          gsub(' ', '_', measure)))

# These objects are no longer necessary
rm(no_pos, N)
```


# Morphometric data aggregated by species

For the following measures, we need a single morphometric value per species:

- Intestinal length / body mass^0.4
- NSA / body mass^0.75
- Villus surface area / body mass^0.75
- Total number of enterocytes (log-transformed; log body mass as covariate)
  * Calculated as such: `log(NSA * enterocyte_density)`


We need the following columns from `morph_df` to compute these values:


```{r spp_measures}
spp_measures <- c('mass', 'intestinal_length', 'nsa', 'vill_surface_area',
                  'enterocyte_density', 'sef')
```


Next I manipulated `morph_df` as such to get means for each parameter that I will be
using for my analyses.

```{r spp_df}
spp_df <- morph_df %>%
    # Changing from tall to wide format
    spread(measure, value) %>% 
    # Selecting measurement columns, plus the identifying columns
    select_(.dots = append(list('diet', 'taxon', 'species', 'id', 'pos'), 
                           spp_measures)) %>% 
    # Removing all rows with all NAs in measures columns
    filter(Reduce(`+`, lapply(.[,spp_measures], is.na)) < length(spp_measures)) %>% 
    # Add nsa to all positions' estimates (for total_enterocytes below)
    group_by(taxon, diet, species, id) %>% 
    mutate(nsa = ifelse(is.na(nsa), nsa[!is.na(nsa)], nsa)) %>% 
    ungroup %>% 
    # Doing the calculations / transformations now, before taking any means
    mutate(log_total_enterocytes = log(enterocyte_density * nsa),
           log_mass = log(mass)) %>% 
    select(taxon, diet, species, id,
           sef, intestinal_length, nsa, vill_surface_area, 
           log_total_enterocytes, log_mass) %>% 
    # Taking mean by individual (i.e., across segments)
    group_by(taxon, diet, species, id) %>% 
    summarize_all(mean, na.rm = TRUE) %>% 
    ungroup %>% 
    # Now taking mean and SE by species
    select(-id) %>% 
    group_by(taxon, diet, species) %>% 
    summarize_all(funs(mean, se), na.rm = TRUE) %>% 
    # Adjusting species with NA for their SE (i.e., those spp with only 1 individual)
    mutate_at(vars(ends_with('_se')), na_se) %>%
    ungroup %>%
    arrange(taxon, diet, species)
```



Lastly I add a column named `stat` to distinguish between mean and SE values, making
filtering for a given statistic easier.

```{r spp_stat}
spp_df <- spp_df %>%
    gather('measure', 'value', -taxon, -diet, -species) %>%
    mutate(stat = sapply(measure, function(s) tail(strsplit(s, '_')[[1]], 1)),
           measure = sapply(measure,
                            function(s) {
                                paste0(head(strsplit(s, '_')[[1]], -1), collapse = "_")
                            })) %>%
    spread(measure, value)
```




# Morphometric data by species AND position

For the following measures, we need 3 morphometric values per species, one per
intestinal segment:

- Intestinal diameter (log-transformed, body mass as covariate)
- Villus height (body mass as covariate)
- Villus width
- Crypt width
- Surface enlargement factor (SEF)
- Enterocyte diameter
- Enterocytes per cm^2 NSA (log-transformed)

We need the following columns from `morph_df` to compute these values:

```{r pos_measure}
pos_measures <- c('mass', 'intestinal_diameter', 'villus_height',  'villus_width',
                  'crypt_width', 'sef', 'enterocyte_diameter', 'enterocyte_density')
```


Next I manipulated `morph_df` as such to get means and standard errors for each
parameter that I will be analyzing.

```{r pos_df}
pos_df <- morph_df %>%
    # Changing from tall to wide format
    spread(measure, value) %>% 
    select_(.dots = append(list('taxon', 'diet', 'species', 'pos', 'id'), 
                           as.list(pos_measures))) %>% 
    # Add mass to all positions' estimates
    group_by(taxon, diet, species, id) %>% 
    mutate(mass = ifelse(is.na(mass), mass[!is.na(mass)], mass)) %>% 
    ungroup %>% 
    # Now removing rows with pos == NA bc they don't have the other measurements
    filter(!is.na(pos)) %>% 
    # Taking the log now, before taking any means
    mutate_(.dots = setNames(as.list(sprintf('%s(%s)', 'log', pos_measures)), 
                             paste0('log_', pos_measures))) %>% 
    # Grouping by, then taking mean and SE of all measurement columns and transformed-
    # measurement columns
    group_by(taxon, diet, species, pos) %>% 
    summarize_at(.vars = c(pos_measures, paste0('log_', pos_measures)), funs(mean, se), 
                 na.rm = TRUE) %>% 
    ungroup %>% 
    # Adjusting species with NA for their SE (i.e., those spp with only 1 individual)
    mutate_at(vars(ends_with('_se')), na_se) %>%
    # Now only outputting columns that are necessary
    select_(
        .dots = as.list(c('taxon', 'diet', 'species', 'pos',
          paste0(rep(c('log_intestinal_diameter', 'villus_height', 'villus_width',
                       'crypt_width', 'sef', 'enterocyte_diameter',
                       'log_enterocyte_density', 'log_mass'), each = 2),
                 c('_mean', '_se'))))
    ) %>%
    arrange(taxon, diet, species, pos)
```



Lastly I add a column named `stat` to distinguish between mean and SE values, making
filtering for a given statistic easier.

```{r gather_pos}
pos_df <- pos_df %>%
    gather('measure', 'value', -taxon, -diet, -species, -pos) %>%
    mutate(stat = sapply(measure, function(s) tail(strsplit(s, '_')[[1]], 1)),
           measure = sapply(measure,
                            function(s) {
                                paste0(head(strsplit(s, '_')[[1]], -1), collapse = "_")
                            })) %>%
    spread(measure, value)
```




# Clearance data



```{r clear_df}
clear_df <- read_csv('output/clean_clearance.csv', col_types = 'ccccdddd') %>%
    mutate(
        # They lumped herbivores and omnivores together as "carb eater <taxon>"
        diet = ifelse(diet == "Protein", diet, "Carb"),
        # Averaging SEF by individual, on log scale
        log_sef = (log(prox) + log(med) + log(dist)) / 3,
        # Taking log of clearance before any means are calculated
        # Some clearances were negative, so there would be NaNs produced
        # The below two lines are to avoid the warning message
        log_clear = ifelse(clear < 0, NA, clear),
        log_clear = log(log_clear)
    ) %>% 
    # These are no longer necessary
    select(-prox, -med, -dist, -clear) %>% 
    group_by(diet, taxon, species) %>% 
    summarize_at(vars(log_sef, log_clear), funs(mean, se), na.rm = TRUE) %>% 
    ungroup
```



I'm going to add in columns `log_enterocyte_density` and `log_mass` from the morphometric
data frame.

```{r gather_clear}
tmp_df <- morph_df %>%
    # Changing from tall to wide format
    spread(measure, value) %>% 
    select(taxon, diet, species, pos, id, mass, enterocyte_density) %>% 
    # Taking the log now, before taking any means
    mutate(log_mass = log(mass), log_enterocyte_density = log(enterocyte_density)) %>% 
    # Grouping by, then taking mean by individual (i.e., among segments)
    group_by(species, id) %>% 
    summarize_at(vars(log_mass, log_enterocyte_density), mean, na.rm = TRUE) %>% 
    ungroup %>% 
    # Now getting mean and SE by species
    group_by(species) %>% 
    summarize_at(vars(log_mass, log_enterocyte_density), funs(mean, se), na.rm = TRUE) %>% 
    ungroup %>% 
    # We don't need SE for log_mass
    rename(log_mass = log_mass_mean) %>% 
    select(-log_mass_se) %>% 
    # Adjusting species with NA for their SE (i.e., those spp with only 1 individual)
    mutate_at(vars(ends_with('_se')), na_se)

# Function to retrieve an X from tmp_df
get_X <- function(X) {
    map_dbl(clear_df$species, function(s) tmp_df[[X]][tmp_df$species == s][1])
}

clear_df <- clear_df %>% 
    mutate(log_mass = get_X('log_mass'),
           log_enterocyte_density_mean = get_X('log_enterocyte_density_mean'),
           log_enterocyte_density_se = get_X('log_enterocyte_density_se'))

rm(tmp_df)
```



I now add a column named `stat` to distinguish between mean and SE values, making
filtering for a given statistic easier. 

```{r clear_stat}
clear_df <- clear_df %>%
    gather('measure', 'value', -diet, -taxon, -species, -log_mass) %>%
    mutate(stat = sapply(measure, function(s) tail(strsplit(s, '_')[[1]], 1)),
           measure = sapply(measure,
                            function(s) {
                                paste0(head(strsplit(s, '_')[[1]], -1), collapse = "_")
                            })) %>%
    spread(measure, value)
```



# Absorption data

The absorption data is a little weird in that different individuals were used for
the various measurements necessary to get the final parameter values for each species.
Because of this, I have to combine these measurements a bit differently than before.

The final parameter, `absorp`, equals the following:

`(gavage / injection) / (nsa * sef)`


This can be manipulated to the following:

`gavage * (1 / injection) * { 1 / (nsa * sef) }`


For three species, the individuals used for measurements for this calculation are 
split into three groups, corresponding to the three portions of the equation above.
One set of individuals were used for `gavage`, another for `injection`, and a third
for `nsa` and `sef`.

These are the above-mentioned three species:

```{r sep_absorps}
sep_absorps <- c('Myotis lucifugus', 'Tadarida brasiliensis', 'Akodon montensis')
```

For the rest of the species, `gavage` and `injection` were measured together, but
`nsa` and `sef` were measured in a different set of individuals.

This is important because `mean(X/Y) != mean(X) / mean(Y)` and
`var(X/Y) != var(X) / var(Y)`.
But because `mean(X*Y) = mean(X) * mean(Y)` and
`var(XY) = mean(X)^2 * var(Y) + mean(Y)^2 * var(X) + var(X) * var(Y)`,
I can inverse things before taking means or variances to allow me to combine
these values.

So before taking means and variances, I have inversed `gavage` and `(nsa * sef)`, 
thereby allowing me to use the equations above.
For the three species with `gavage` and `injection` measured separately, I had to 
combine variances for `gavage` and `injection` first, then combine the variance of
`gavage * injection` with `1 / (nsa * sef)`.

The term `1 / (nsa * sef)` is called `ns` below.



```{r absorp_df}
absorp_df <- read_csv('output/clean_absorption.csv', col_types = 'ccccddddddd') %>%
    mutate(
        # Averaging SEF by individual (i.e., across segments)
        sef = (prox + med + dist) / 3,
        ns = 1 / (nsa * sef),
        log_mass = log(mass)
    ) %>% 
    group_by(diet, taxon, species) %>% 
    summarize(
        gavage_v = var(gavage, na.rm = TRUE),
        gavage = mean(gavage, na.rm = TRUE),
        
        # For non-sep_absorps species, I'm setting injection mean to 1 and variance to 0
        # bc the final value is already in the gavage column, and doing this makes the
        # equation for combined varianced above simplify to = V(X), where X is gavage.
        # It also makes the mean end up equalling just the gavage mean.
        inv_injection_v = ifelse(species[1] %in% sep_absorps,
                                 var(1 / injection, na.rm = TRUE), 0),
        inv_injection = ifelse(species[1] %in% sep_absorps,
                               mean(1 / injection, na.rm = TRUE), 1),
        
        # "gi_" stands for gavage and injection
        gi_v = gavage^2 * inv_injection_v + inv_injection^2 * gavage_v +
            gavage_v * inv_injection_v,
        gi = gavage * inv_injection,
        
        ns_v = var(ns, na.rm = TRUE),
        ns = mean(ns, na.rm = TRUE),
        
        # I added the sqrt bc I want the output to be the standard deviation (the closest 
        # to standard error I've figure out to get)
        absorp_se = sqrt(ns^2 * gi_v + gi^2 * ns_v + ns_v * gi_v),
        absorp_mean = gavage * inv_injection * ns,
        
        # I don't need SE for log_mass because I'm assuming it's without error
        log_mass = mean(log_mass, na.rm = TRUE)
    ) %>% 
    ungroup %>% 
    select(taxon, species, absorp_mean, absorp_se, log_mass)

rm(sep_absorps)
```



I'm going to add in the column `log_total_enterocytes` from the morphometric data frame.

```{r gather_absorp}
# Function to get log_total_enterocytes from spp_df
get_lte <- function(.stat) {
    map_dbl(absorp_df$species, function(s) {
        .df <- spp_df %>% filter(species == s, stat == .stat)
        return(.df$log_total_enterocytes[1])
    })
}
absorp_df <- absorp_df %>% 
    mutate(log_total_enterocytes_mean = get_lte('mean'),
           log_total_enterocytes_se = get_lte('se'))

rm(get_lte)
```


As above, I add a column named `stat` to distinguish between mean and SE values, making
filtering for a given statistic easier.

```{r absorp_stat}
absorp_df <- absorp_df %>%
    gather('measure', 'value', -taxon, -species, -log_mass) %>%
    mutate(stat = sapply(measure, function(s) tail(strsplit(s, '_')[[1]], 1)),
           measure = sapply(measure,
                            function(s) {
                                paste0(head(strsplit(s, '_')[[1]], -1), collapse = "_")
                            })) %>%
    spread(measure, value)
```



# Saving these data frames

I'm saving them as csv files so they can be quickly loaded when retrieving a data frame.

```{r save_dfs, eval = TRUE}
write_csv(pos_df, 'output/tidy_pos.csv')
write_csv(spp_df, 'output/tidy_spp.csv')
write_csv(clear_df, 'output/tidy_clear.csv')
write_csv(absorp_df, 'output/tidy_absorp.csv')
```




# Session info

This outlines the package versions I used for this script.

```{r session_info, echo = FALSE}
devtools::session_info()
```

