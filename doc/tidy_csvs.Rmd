---
title: "Clean CSVs into simpler data frames"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```


This reads the cleaned CSV files with data for individual animals and simplifies 
them into CSV files with means by species and/or intestinal segment.
It needs to be run only once, and not at all if you have the csv files already.

# Summary of output

I created two data sets from morphometric data in `output/clean_morph.csv`:

1. Measurements separated by species (found in `output/tidy_spp.csv`)
2. Measurements separated by species and intestinal segment (`output/tidy_pos.csv`)

I also created one data set each from `output/clean_clearance.csv` and
`output/clean_absorption.csv`.
These csvs are found in `output/tidy_clear.csv` and `output/tidy_absorp.csv`, 
respectively.

Each data set is associated with a set of analyses and only needs certain measurements, 
so only those are included.

The csv files are used in the function `get_df` in the `R/get_data.R` file to 
retrieve a data frame for a given analysis set.
__The analysis sets are as follows\:__

1. `'spp'`: Measurements separated by species.
2. `'pos'`: Measurements by species and position. (You have to also provide the 
   position for this analysis set.)
3. `'clear'`: Clearance data by species. (Uses a different set of individuals entirely
   from the 1–2.)
4. `'absorp'`: Absorption data by species. (Uses a different set of individuals entirely
   from the 1–3.)


For the second analysis set, I need to do the analyses separately for each position 
because modelling within-species and within-individual variance due to position 
rather than process error would be difficult and not likely possible with this small
dataset.



# Getting started

__Load packages\:__
 
```{r packages}
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(magrittr)
    library(purrr)
})
```


# Full morphometric data frame

This data frame of morphometric measurements will be useful for the next two sections.

```{r morpho}
morph_df <- read_csv('output/clean_morph.csv', col_types = 'cccccddd') %>%
    # Oligoryzomys seems to be the more standard spelling
    mutate(species = ifelse(species == 'Olygoryzomys nigripes', 
                            'Oligoryzomys nigripes', species))

# Number of individuals
N <- morph_df$id %>% unique %>% length

# Measures with no position (i.e., NA in pos column instead of prox, med, or dist)
no_pos <- morph_df %>% 
    filter(is.na(dist)) %>% 
    group_by(measure) %>% 
    summarize(total = n()) %>% 
    filter(total == N) %>% 
    select(measure) %>% 
    unlist %>% 
    paste

# Gathering into 'tall' format, fixing position column, removing spaces from 
# measure column, and changing the "enterocyte_width" measure to "enterocyte_diameter".
morph_df <- morph_df %>% 
    gather(pos, value, prox:dist, na.rm = TRUE) %>% 
    mutate(pos = ifelse(measure %in% no_pos, NA, pos),
           measure = gsub('enterocyte_width', 'enterocyte_diameter', 
                          gsub(' ', '_', measure)))

# These objects are no longer necessary
rm(no_pos, N)
```


# Morphometric data aggregated by species

For the following measures, we need a single morphometric value per species:

- Intestinal length / body mass^0.4
- NSA / body mass^0.75
- Villus surface area / body mass^0.75
- Total number of enterocytes (log-transformed; log body mass as covariate)
  * Calculated as such: `log(NSA * enterocyte_density)`


We need the following columns from `morph_df` to compute these values:


```{r spp_measures}
spp_measures <- c('mass', 'intestinal_length', 'nsa', 'vill_surface_area',
                  'enterocyte_density', 'sef')
```


Next I manipulated `morph_df` as such to get means for each parameter that I will be
using for my analyses.

```{r spp_df}
spp_df <- morph_df %>%
    # Changing from tall to wide format
    spread(measure, value) %>% 
    # Selecting measurement columns, plus the identifying columns
    select_(.dots = append(list('diet', 'taxon', 'species', 'id', 'pos'), 
                           spp_measures)) %>% 
    # Removing all rows with all NAs in measures columns
    filter(Reduce(`+`, lapply(.[,spp_measures], is.na)) < length(spp_measures)) %>% 
    # Add nsa to all positions' estimates (for total_enterocytes below)
    group_by(taxon, diet, species, id) %>% 
    mutate(nsa = ifelse(is.na(nsa), nsa[!is.na(nsa)], nsa)) %>% 
    ungroup %>% 
    # Doing the calculations / transformations now, before taking any means
    mutate(log_total_enterocytes = log(enterocyte_density * nsa),
           log_mass = log(mass)) %>% 
    select(taxon, diet, species, id,
           sef, intestinal_length, nsa, vill_surface_area, 
           log_total_enterocytes, log_mass) %>% 
    # Taking mean by individual (i.e., across segments)
    group_by(taxon, diet, species, id) %>% 
    summarize_all(mean, na.rm = TRUE) %>% 
    ungroup %>% 
    # Now taking mean by species
    select(-id) %>% 
    group_by(taxon, diet, species) %>% 
    summarize_all(mean, na.rm = TRUE) %>% 
    ungroup %>%
    arrange(taxon, diet, species)
```






# Morphometric data by species AND position

For the following measures, we need 3 morphometric values per species, one per
intestinal segment:

- Intestinal diameter (log-transformed, body mass as covariate)
- Villus height (body mass as covariate)
- Villus width
- Crypt width
- Surface enlargement factor (SEF)
- Enterocyte diameter
- Enterocytes per cm^2 NSA (log-transformed)

We need the following columns from `morph_df` to compute these values:

```{r pos_measure}
pos_measures <- c('mass', 'intestinal_diameter', 'villus_height',  'villus_width',
                  'crypt_width', 'sef', 'enterocyte_diameter', 'enterocyte_density')
```


Next I manipulated `morph_df` as such to get means and standard errors for each
parameter that I will be analyzing.

```{r pos_df}
pos_df <- morph_df %>%
    # Changing from tall to wide format
    spread(measure, value) %>% 
    select_(.dots = append(list('taxon', 'diet', 'species', 'pos', 'id'), 
                           as.list(pos_measures))) %>% 
    # Add mass to all positions' estimates
    group_by(taxon, diet, species, id) %>% 
    mutate(mass = ifelse(is.na(mass), mass[!is.na(mass)], mass)) %>% 
    ungroup %>% 
    # Now removing rows with pos == NA bc they don't have the other measurements
    filter(!is.na(pos)) %>% 
    # Taking the log now, before taking any means
    mutate_(.dots = setNames(as.list(sprintf('%s(%s)', 'log', pos_measures)), 
                             paste0('log_', pos_measures))) %>% 
    # Grouping by, then taking mean of all measurement columns and transformed-
    # measurement columns
    group_by(taxon, diet, species, pos) %>% 
    summarize_at(.vars = c(pos_measures, paste0('log_', pos_measures)), mean, 
                 na.rm = TRUE) %>% 
    ungroup %>% 
    # Now only outputting columns that are necessary
    select(taxon, diet, species, pos, 
           log_intestinal_diameter, villus_height, villus_width, crypt_width, sef,
           enterocyte_diameter, log_enterocyte_density, log_mass) %>% 
    arrange(taxon, diet, species, pos)
```




# Clearance data



```{r clear_df}
clear_df <- read_csv('output/clean_clearance.csv', col_types = 'ccccdddd') %>%
    mutate(
        # They lumped herbivores and omnivores together as "carb eater <taxon>"
        diet = ifelse(diet == "Protein", diet, "Carb"),
        # Averaging SEF by individual, on log scale
        log_sef = (log(prox) + log(med) + log(dist)) / 3,
        # Taking log of clearance before any means are calculated
        # Some clearances were negative, so there would be NaNs produced
        # The below two lines are to avoid the warning message
        log_clear = ifelse(clear < 0, NA, clear),
        log_clear = log(log_clear)
    ) %>% 
    # These are no longer necessary
    select(-prox, -med, -dist, -clear) %>% 
    group_by(diet, taxon, species) %>% 
    summarize_at(vars(log_sef, log_clear), mean, na.rm = TRUE) %>% 
    ungroup
```



I'm going to add in columns `log_enterocyte_density` and `log_mass` from the morphometric
data frame.

```{r gather_clear}
tmp_df <- pos_df %>% 
    group_by(species) %>% 
    summarize(log_mass = mean(log_mass), 
              log_enterocyte_density = mean(log_enterocyte_density))

for (cn in c('log_mass', 'log_enterocyte_density')) {
    clear_df[[cn]] <- map_dbl(clear_df$species, 
                              function(s) tmp_df[[cn]][tmp_df$species == s][1])
}; rm(cn)

rm(tmp_df)
```






# Absorption data

The absorption data is a little weird in that different individuals were used for
the various measurements necessary to get the final parameter values for each species.
Because of this, I have to combine these measurements a bit differently than before.

The final parameter, `absorp`, equals the following:

`(gavage / injection) / (nsa * sef)`


This can be manipulated to the following:

`gavage * (1 / injection) * { 1 / (nsa * sef) }`


For three species, the individuals used for measurements for this calculation are 
split into three groups, corresponding to the three portions of the equation above.
One set of individuals were used for `gavage`, another for `injection`, and a third
for `nsa` and `sef`.

These are the above-mentioned three species:

```{r sep_absorps}
sep_absorps <- c('Myotis lucifugus', 'Tadarida brasiliensis', 'Akodon montensis')
```

For the rest of the species, `gavage` and `injection` were measured together, but
`nsa` and `sef` were measured in a different set of individuals.

This is important because `mean(X/Y) != mean(X) / mean(Y)`.
But because `mean(X*Y) = mean(X) * mean(Y)`,
I can inverse things before taking means to allow me to combine these values.

So before taking means, I have inversed `gavage` and `(nsa * sef)`, 
thereby allowing me to use the equations above.
For the three species with `gavage` and `injection` measured separately, I had to 
combine variances for `gavage` and `injection` first, then combine the variance of
`gavage * injection` with `1 / (nsa * sef)`.

The term `1 / (nsa * sef)` is called `ns` below.



```{r absorp_df}
absorp_df <- read_csv('output/clean_absorption.csv', col_types = 'ccccddddddd') %>%
    mutate(
        # Averaging SEF by individual (i.e., across segments)
        sef = (prox + med + dist) / 3,
        ns = 1 / (nsa * sef),
        log_mass = log(mass)
    ) %>% 
    group_by(diet, taxon, species) %>% 
    summarize(
        gavage = mean(gavage, na.rm = TRUE),
        
        # For non-sep_absorps species, I'm setting injection mean to 1 
        # bc the final value is already in the gavage column, and doing this makes the
        # mean end up equalling just the gavage mean.
        inv_injection = ifelse(species[1] %in% sep_absorps,
                               mean(1 / injection, na.rm = TRUE), 1),
        
        # "gi_" stands for gavage and injection
        gi = gavage * inv_injection,
        
        ns = mean(ns, na.rm = TRUE),
        
        absorp = gavage * inv_injection * ns,
        
        log_mass = mean(log_mass, na.rm = TRUE)
    ) %>% 
    ungroup %>% 
    select(taxon, species, absorp, log_mass)

rm(sep_absorps)
```



I'm going to add in the column `log_total_enterocytes` from the morphometric data frame.

```{r gather_absorp}
absorp_df <- absorp_df %>% 
    mutate(
        log_total_enterocytes = 
            map_dbl(species, function(s) {
                spp_df$log_total_enterocytes[spp_df$species == s][1]
            }))
```





# Saving these data frames

I'm saving them as csv files so they can be quickly loaded when retrieving a data frame.

```{r save_dfs, eval = TRUE}
write_csv(pos_df, 'output/tidy_pos.csv')
write_csv(spp_df, 'output/tidy_spp.csv')
write_csv(clear_df, 'output/tidy_clear.csv')
write_csv(absorp_df, 'output/tidy_absorp.csv')
```




# Session info

This outlines the package versions I used for this script.

```{r session_info, echo = FALSE}
devtools::session_info()
```

