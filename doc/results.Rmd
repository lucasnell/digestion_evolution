--- 
title: "phylolm results" 
author: "Lucas Nell" 
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`" 
output: 
  github_document: 
    toc: true 
    toc_depth: 1 
--- 
 
```{r setup, include = FALSE, cache = FALSE} 
knitr::opts_chunk$set(echo = FALSE) 
knitr::opts_knit$set(root.dir = normalizePath(".."))
``` 
 
 
This script displays results from analyses using
[`phylolm::phylolm`](https://doi.org/10.1093/sysbio/syu005) and 
a modified version of [`ape::corphylo`](https://CRAN.R-project.org/package=ape)
(methods paper link 
[here](http://onlinelibrary.wiley.com/doi/10.1111/j.1365-2435.2009.01596.x/full)).

The `parameter` column indicates which variable (either an X variable or phylogenetic 
signal) that row's numbers refer to.
Column `estimate` is the maximum likelihood estimate for the specified `parameter`, 
while `lower` and `upper` are lower and upper bounds of the 95% confidence interval
for the coefficient estimate, obtained by parametric bootstrapping.
`P` is the p-value for an estimate not equal to zero; this is obtained by the same 
bootstrapping as for the CI.
I do not present P-values for phylogenetic signals because they were bound
above zero by the models; thus confidence intervals are more informative.

Within a given table, multiple `parameter` values for a given `Y` never indicate 
that separate analyses were performed for each `parameter`.


 
```{r libraries}
# Packages needed for this script 
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(stringr)
    library(purrr)
    library(phylolm)
    library(ape)
    library(ggplot2)
    library(grid)
    library(gridExtra)
})
# Set default ggplot2 theme
theme_set(theme_classic())
# Custom package that does bootstrapping on corphylo object
suppressMessages(devtools::load_all('corphyloCpp'))
# Sourcing scripts from R directory
invisible(sapply(list.files('R', '*.R', full.names = TRUE), source))
``` 
 
 
```{r parse_output} 
summ_df <- read_csv('output/models_summaries.csv', col_types = 'cccdddd') %>%
    mutate(X = ifelse(X == 'cladeBat', 'clade', X),
           pos = ifelse(is.na(pos), 'all', pos)) %>%  
    rename(estimate = value) %>%
    select(pos, Y, X, estimate, lower, upper, P) %>% 
    mutate_if(is.numeric, function(s) sprintf('%.4g', s)) %>% 
    mutate(model = ifelse((X %in% c('absorp', 'log_clear', 'd') | 
                               Y %in% c('absorp', 'log_clear')) & 
                              !X %in% c('clade', 'lambda', 'log_mass'), 
                          'corphylo','phylolm'),
           P = ifelse(X %in% c('lambda', 'd'), "â€“", P)) %>% 
    rename(parameter = X) %>% 
    nest(-model, -pos)
plm_mods <- list(absorp = read_rds('output/models_absorp.rds'),
               diet = read_rds('output/models_diet.rds'),
               pos = read_rds('output/models_pos.rds'),
               spp = read_rds('output/models_spp.rds'))
cp_mods <- read_rds('output/models_corphylo.rds')
``` 
 

# `phylolm` estimates

Below, the `parameter` column names coefficients (i.e., X variables), except for
when `parameter == "lambda"`.
When `parameter == "lambda"`, this refers to the phylogenetic correlation parameter
(Pagel's lambda).


## Positions combined 
 
```{r spp_summs} 
knitr::kable(filter(summ_df, pos == 'all', model == 'phylolm')$data[[1]] %>% 
    arrange(Y, parameter) %>%
    mutate(Y = ifelse(Y == lag(Y, default = 'XXX'), "", Y)))
``` 
 
 
## Proximal 
 
```{r prox_summs} 
knitr::kable(filter(summ_df, pos == 'prox', model == 'phylolm')$data[[1]] %>% 
    arrange(Y, parameter) %>%
    mutate(Y = ifelse(Y == lag(Y, default = 'XXX'), "", Y)))
``` 
 
 
## Medial 
 
```{r med_summs} 
knitr::kable(filter(summ_df, pos == 'med', model == 'phylolm')$data[[1]] %>% 
    arrange(Y, parameter) %>%
    mutate(Y = ifelse(Y == lag(Y, default = 'XXX'), "", Y)))
``` 
 
 
## Distal 
 
```{r dist_summs} 
knitr::kable(filter(summ_df, pos == 'dist', model == 'phylolm')$data[[1]] %>% 
    arrange(Y, parameter) %>%
    mutate(Y = ifelse(Y == lag(Y, default = 'XXX'), "", Y)))
``` 


# `corphylo` estimates

Below, when `parameter != "d"`, that row refers to the correlation between the
`Y` and `parameter` variables. There are no real X and Y variables here.

When `parameter == "d"`, this row refers to the phylogenetic signal from an 
Ornstein-Uhlenbeck process for variable `Y`.

# `Clearance` and `SEF`

```{r clear_sef_kable}
knitr::kable(filter(summ_df, model == 'corphylo')$data[[1]][1:3,])
```

# `Clearance` and `log_enterocyte_density`

```{r clear_ed_kable}
knitr::kable(filter(summ_df, model == 'corphylo')$data[[1]][4:6,])
```


# `Absorption` and `log_total_enterocytes`

```{r absorp_te_kable}
knitr::kable(filter(summ_df, model == 'corphylo')$data[[1]][7:9,])
```





# Influential values


## Jackknifing

In the `phylolm` model for `log_intestinal_length ~ clade`, one point is very
influential to the results, which makes me less confident in the conclusions from the
full dataset.
Below I use jackknifing to determine how influential each point is to the `log_mass`
and `clade` estimates.

(See `R/model_summaries.R` for the `jack_phylolm` function.)

```{r influence_jack, echo = TRUE}
# Conducting jackknifing
int_jack <- jack_phylolm(plm_mods$spp$log_intestinal_length, phy = get_tr('spp'))
```


The plot below shows log(intestinal length) on log(body mass) with point sizes 
indicating that point's absolute jackknife influence value for the maximum likelihood
estimate for (A) clade, (B) log(body mass), and (C) intercept.
Color indicates clade.


```{r influence_plots}
# Keep the same area options for every plot
area_opts <- scale_size_area(breaks = c(0.5, 1.0), max_size = 4)

get_infl <- function(species, .est) {
    max_infl <- max(abs({int_jack %>% filter(estimate == .est)}$influence))
    sapply(species, 
           function(s) {
               infl <- abs({int_jack %>% 
                       filter(species == s, estimate == .est)}$influence[1])
               return(infl / max_infl)
           })
}

add_title <- function(.p, .title) {
    if (.p$labels$x == 'pos') {
        suppressMessages({
            .p <- .p + 
                scale_x_continuous(breaks = 1:3, limits = c(0.4, 3.43),
                                   labels = c('Proximal', 'Medial', 'Distal'))
        })
    }
    x_range <- ggplot_build(.p)$layout$panel_ranges[[1]]$x.range
    y_range <- ggplot_build(.p)$layout$panel_ranges[[1]]$y.range
    if (!is.null(.p$coordinates$trans$x)) {
        x_range <- .p$coordinates$trans$x$inverse(x_range)
    }
    if (!is.null(.p$coordinates$trans$y)) {
        y_range <- .p$coordinates$trans$y$inverse(y_range)
    }
    min_x <- min(x_range) + 0.02 * diff(x_range)
    max_y <- max(y_range) - 0.02 * diff(y_range)
    .p <- .p + 
        geom_text(data = NULL, label = .title, 
                  x = min_x, y = max_y, hjust = 0, vjust = 1, 
                  size = 14 * (25.4/72), fontface = 'plain', color = 'black')
    return(.p)
}


infl_plots <- function(estimate, guide_area = TRUE, guide_color = TRUE, title_ = NULL) {

    p <- get_df('spp') %>%
        mutate(influence = get_infl(species, estimate)) %>% 
        ggplot(aes(log_mass, log_intestinal_length, color = clade, size = influence)) +
        geom_point() +
        xlab('log(body mass [g])') +
        ylab('log(intestinal length [cm])') +
        theme(axis.title = element_blank(), plot.title = element_text(size = 12))
    if (guide_area) {
        p <- p + scale_size_area(breaks = c(0.5, 1.0), max_size = 4)
    } else {
        p <- p + scale_size_area(breaks = c(0.5, 1.0), max_size = 4, guide = FALSE)
    }
    if (guide_color) {
        p <- p + scale_color_manual(values = c('firebrick2', 'dodgerblue'))
    } else {
        p <- p + scale_color_manual(values = c('firebrick2', 'dodgerblue'), guide = FALSE)
    }
    if (!is.null(title_)) {
        p <- add_title(p, title_)
    }
    return(p)
}

# Plotting influence on `cladeBat` onto plot of log_intestinal_length ~ log_mass
infl_clade <- infl_plots('cladeBat', guide_area = FALSE, guide_color = FALSE, 'A') +
    ggtitle('clade')

# Plotting influence on `log_mass` onto plot of log_intestinal_length ~ log_mass
infl_mass <- infl_plots('log_mass', TRUE, TRUE, 'B') +
    ggtitle('log(mass)')

# Plotting influence on `(Intercept)` onto plot of log_intestinal_length ~ log_mass
infl_int <- infl_plots('intercept', FALSE, FALSE, 'C') +
    ggtitle('intercept')

# To extract the legend from a ggplot object
g_legend <- function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

.legend <- g_legend(infl_mass)

.ylab <- ggplot(data_frame(x = 0, y = 0), aes(x, y)) +
    geom_text(label = 'log(intestinal length [cm])', angle = 90) +
    theme_void()
.xlab <- ggplot(data_frame(x = 0, y = 0), aes(x, y)) +
    geom_text(label = 'log(mass [g])') +
    theme_void()
.void <- ggplot() + geom_blank()

grobs <- grid.arrange(.void, ggplotGrob(infl_clade), .void,
                      .ylab, ggplotGrob(infl_mass + theme(legend.position = 'none')), .legend,
                      .void, ggplotGrob(infl_int), .void,
                      .void, .xlab, .void,
                      ncol = 3, nrow = 4, widths = c(1/10, 7/10, 2/10), 
                      heights = c(1, 1, 1, 1/10))

quartz(type = 'pdf', file = "figs/influence.pdf", family = 'Helvetica', 
       width = 4, height = 8)
grid.draw(grobs)
invisible(dev.off())
```

![influence figure](figs/influence.pdf "Plot of influence values")


## Re-running model without influential point

Below is the model summary including all values.

```{r influence_firstrun}
plm_mods$spp$log_intestinal_length %>% summary
```


Now the results without including the most influential value:

```{r influence_rerun}
spp_df <- get_df('spp')
spp_tr <- get_tr('spp')

.df <- get_df('spp')
.df <- .df[.df$species != 'Artibeus lituratus',]
.tr <- get_tr('spp') %>% filter_tr(.df$species)
z <- phylolm(log_intestinal_length ~ clade + log_mass, model = 'lambda',
        data = .df, boot = 2000, phy = .tr)
z %>% summary
pval(z, 'cladeBat')
pval(plm_mods$spp$log_intestinal_length, 'cladeBat')
```


We can see that we're much less sure about mass's influence on intestinal length when
we remove that one point.



# Percent differences

This is for the percent differences in the discussion and abstract.

I calculated rodent and bat estimates at `log(body mass) = 0` to remove the effect
of body mass.
If the variable was log-transformed (all those below were), then I exponentiated
both rodent and bat estimates before computing the proportional, then percentage, 
difference.

```{r percent_diff, echo = TRUE}
perc_diff <- function(.mod) {
    
    # Detect log-transform from formula
    logged <- grepl('^log', paste(.mod$formula)[2])
    
    coefs <- {.mod %>% summary %>% coef}[,'Estimate']
    rodents <- coefs[['(Intercept)']]
    bats <- rodents + coefs[['cladeBat']]
    if (logged) {
        rodents <- exp(rodents)
        bats <- exp(bats)
    }
    prop_diff <- (bats - rodents) / rodents
    return(prop_diff * 100)
}
```

## NSA
```{r percent_diff_nsa, echo = TRUE}
cat(sprintf('%.4g %%\n', perc_diff(plm_mods$spp$log_nsa)))
```

## SEF
```{r percent_diff_sef, echo = TRUE}
cat(sprintf('%.4g %%\n', mean(c(
    perc_diff(plm_mods$pos$prox$log_sef),
    perc_diff(plm_mods$pos$med$log_sef),
    perc_diff(plm_mods$pos$dist$log_sef)
))))
```

## Enterocyte density
```{r percent_diff_ent_dens, echo = TRUE}
cat(sprintf('%.4g %%\n', mean(c(
    perc_diff(plm_mods$pos$prox$log_enterocyte_density), 
    perc_diff(plm_mods$pos$med$log_enterocyte_density), 
    perc_diff(plm_mods$pos$dist$log_enterocyte_density)
))))
```





# SEF on Clade and log(Mass)

This is to determine whether there's an effect of body mass on SEF. It appears there
is not.

```{r sef_clade_mass, echo = TRUE}
tr <- get_tr('spp')
spp_df <- get_df('spp')
set.seed(940318092)
mod <- suppressWarnings(
    phylolm(log_sef ~ clade + log_mass, data = spp_df, phy = tr, model = "lambda",
            boot = 2000))
# P-values for coefficient estimates != 0, using parametric bootstrapping:
pval(mod, c('log_mass', 'cladeBat'))
```

