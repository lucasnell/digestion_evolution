---
title: "Phylogenetic linear regression"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
tz: "CST6CDT"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```




Loading packages:


```{r load_packages}
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(phylolm)
    library(ape)
})
```


# `source` the `R` directory

The `R` directory provides functions to summarize `phylolm` objects, run a version
of `ape::corphylo` with confidence interval output, and retrieve morphometric,
clearance, and absorption data.
See `tidy_csvs.md` for more info.

```{r source_R}
invisible(sapply(list.files('R', '*.R', full.names = TRUE), source))
```


The `get_tr` function in `R/get_data.R` reads the main phylogenetic tree, 
cleans species names, and removes unnecessary species from it for a given analysis set.

The function `ci` in `R/model_summaries.R` gets 95% CIs from a bootstrapped 
`phylolm` model object.

The function `ci_df` creates a tibble with 95% CIs for all parameters in a 
single model.


# `SEF` on `Diet`

Necessary data:

> The `spp_df` data frame is used for both this analysis and `Morphometrics` on `Taxon`.
> The `tr` tree is used for this analysis, `Morphometrics` on `Taxon`, and
> `Morphometrics` on `Taxon`, separately by segment.

```{r diet_data}
spp_df <- get_df('spp')
tr <- get_tr('spp')
```


`phylolm` call and output:

```{r sef_diet}
set.seed(581120)
diet_fit <- phylolm(sef ~ diet, data = spp_df, phy = tr, 
                    model = 'lambda', boot = 2000)
summary(diet_fit)
```



# `Absorption` on `Taxon`

"Absorption" here means `Fractional absorption / (total intestinal surface / mass^0.75)`,
where `total intestinal surface = NSA * SEF`


Necessary data:

```{r absorp_data}
absorp_df <- get_df('absorp')
absorp_tr <- get_tr('absorp')
```

`phylolm` call and output:

```{r absorp_taxon}
set.seed(454094511)
absorp_fit <- suppressWarnings(  # gives warning about lambda being very low
    phylolm(absorp ~ taxon, data = absorp_df, phy = absorp_tr, 
            model = 'lambda', boot = 2000)
)
summary(absorp_fit)
```


I'm saving output for this fit because I'll be using that for plotting.

```{r save_absorp, purl = FALSE}
readr::write_rds(absorp_fit, 'output/models_absorp.rds')
```



# `Morphometrics` on `Taxon`

List of `Morphometrics`:

- Intestinal length / body mass^0.4
- NSA / body mass^0.75
- Villus surface area / body mass^0.75
- Total number of enterocytes (log-transformed; log body mass as covariate)
    * Calculated as such: `log(NSA * enterocyte_density)`


These are the column names for the above parameters:
```{r sp_analyses_cols}
spp_ys <- c("int_length_mass", "nsa_mass", "vill_area_mass", "log_total_enterocytes")
```


Necessary data:
`spp_df` and `tr` are already created from fitting `sef ~ diet`.


`phylolm` call:

> The actual analyses (takes ~6.5 min, which is why I saved the output):

```{r sp_analyses, eval = FALSE}
set.seed(88754829)
spp_fits <- lapply(
    spp_ys,
    function(y) {
        f <- paste(y, ' ~ taxon',
                   ifelse(grepl('total_enterocytes', y), '+ log_mass', ''))
        suppressWarnings(
            do.call("phylolm", list(as.formula(f), data = as.name("spp_df"),
                                    phy = as.name("tr"), model = 'lambda',
                                    boot = 2000))
        )
    })
names(spp_fits) <- spp_ys
readr::write_rds(spp_fits, 'output/models_spp.rds')
```

Loading the output and summarizing:

```{r sp_analyses_load, purl = FALSE}
spp_fits <- readr::read_rds('output/models_spp.rds')
sapply(spp_fits, ci)
ci(spp_fits$log_total_enterocytes, parameter = 'log_mass')
```








# `Morphometrics` on `Taxon`, separately by segment


(Segment = proximal, medial, or distal)

List of `Y`s:

- Intestinal diameter (log-transformed, body mass as covariate)
- Villus height (body mass as covariate)
- Villus width
- Crypt width
- Surface enlargement factor (SEF)
- Enterocyte diameter
- Enterocytes per cm^2 NSA (log-transformed)




Below are the column names for these parameters and all the segment types.

```{r pos_ys}
pos_ys <- c('log_intestinal_diameter', 'villus_height', 'villus_width', 
            'crypt_width', 'sef', 'enterocyte_diameter', 'log_enterocyte_density')
seg_types <- c('prox', 'med', 'dist')
```


`phylolm` call:

The actual analyses (takes ~21.7 min, which is why I saved the output):

```{r pos_analyses, eval = FALSE}
set.seed(25413535)
pos_fits <- lapply(
    seg_types,
    function(pos) {
        # Assigning to obj named <pos>_df so that the call identifies the position
        assign(paste0(pos, '_df'), get_df('pos', .pos = pos))
        lapply(
            pos_ys,
            function(y) {
                f <- paste(y, ' ~ taxon',
                           ifelse(grepl('intestinal_diameter|villus_height', y),
                                  '+ log_mass', ''))
                arg_list <- list(
                    as.formula(f),
                    data = as.name(paste0(pos, "_df")),
                    phy = as.name("tr"), model = 'lambda',
                    boot = 2000)
                # These models don't find the peak likelihood unless specifying a
                # starting value of 0.1.
                if ((y == "log_enterocyte_density" & pos == "med") |
                    (y == "crypt_width" & pos == "prox")) {
                    arg_list <- c(arg_list, starting.value = 0.1)
                }
                # Now call phylolm
                suppressWarnings(do.call("phylolm", arg_list))
            })
    })
names(pos_fits) <- seg_types
for (i in 1:length(pos_fits)) names(pos_fits[[i]]) <- pos_ys; rm(i)
readr::write_rds(pos_fits, 'output/models_pos.rds')
```

Loading the output and summarizing:

```{r pos_analyses_load, purl = FALSE}
pos_fits <- readr::read_rds('output/models_pos.rds')
sapply(pos_fits$dist, ci)
sapply(pos_fits$med, ci)
sapply(pos_fits$prox, ci)
sapply(pos_fits$dist[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
sapply(pos_fits$med[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
sapply(pos_fits$prox[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
```












# `Clearance` on `SEF`

Clearance = "paracellular probe L-arabinose clearance"

Both are log-transformed.

From the original manuscript: 
> ... we used reduced major axis regression (model II regression)... because both 
> variables [X and Y] were subject to error

Instead of an RMA regression, I'll be using a modified version of `ape::corphylo` 
to estimate Pearson correlation coefficients.
Confidence intervals are calculated using Fisher information.

```{r clear_sef}

clear_df <- get_df('clear')
clear_se_df <- get_df('clear', .stat = 'se')  # <-- contains standard errors
clear_tr <- get_tr('clear')

Xmat <- cbind(clear_df$log_sef, clear_df$log_clear)
rownames(Xmat) <- rownames(clear_df)

MEmat <- cbind(clear_se_df$log_sef, clear_se_df$log_clear)
rownames(MEmat) <- clear_se_df$species

clear_cor <- corp(Xmat, phy = clear_tr, SeM = MEmat)

# Correlation with 95% CI
clear_cor['r',]
```





# Assembling all output into one object




I ran `ci_df` on all models above.
I also added the output from the correlation between `log_sef` and `log_clear` 
manually at the end, which I have to do because it isn't a `phylolm` object.


```{r mod_summaries, purl = FALSE}
mod_summaries <- bind_rows(
    list(
        ci_df(diet_fit),
        ci_df(absorp_fit),
        bind_rows(lapply(spp_fits, ci_df)),
        bind_rows(
            lapply(names(pos_fits), function(p) {
                bind_rows(lapply(pos_fits[[p]], ci_df, .pos = p))
            })),
        bind_cols(X = 'log_clear', Y = 'log_sef', clear_cor['r',])
        ))
knitr::kable(mod_summaries, format = 'markdown')
```


I lastly write this summary to a csv file.


```{r write_summaries, purl = FALSE}
write_csv(mod_summaries, 'output/models_summaries.csv')
```




# Session info

This outlines the package versions I used for these analyses.

```{r session_info, echo = FALSE, purl = FALSE}
devtools::session_info()
```
