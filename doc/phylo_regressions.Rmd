---
title: "Phylogenetic linear regression"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
tz: "CST6CDT"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```




Loading packages:


```{r load_packages}
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(purrr)
    library(phylolm)
    library(ape)
})
devtools::load_all('corphyloCpp')
```


# `source` the `R` directory

The `R` directory provides functions to summarize `phylolm` objects, run a version
of `ape::corphylo` with confidence interval output, and retrieve morphometric,
clearance, and absorption data.
See `tidy_csvs.md` for more info.

```{r source_R}
invisible(sapply(list.files('R', '*.R', full.names = TRUE), source))
```


The `get_tr` function in `R/get_data.R` reads the main phylogenetic tree, 
cleans species names, and removes unnecessary species from it for a given analysis set.

The function `ci` in `R/model_summaries.R` gets 95% CIs from a bootstrapped 
`phylolm` model object.

The function `ci_df` creates a tibble with 95% CIs for all parameters in a 
single model.


# `SEF` on `Diet`

Necessary data:

> The `spp_df` data frame is used for both this analysis and `Morphometrics` on `Taxon`.
> The `tr` tree is used for this analysis, `Morphometrics` on `Taxon`, and
> `Morphometrics` on `Taxon`, separately by segment.

```{r diet_data}
spp_df <- get_df('spp')
tr <- get_tr('spp')
```


`phylolm` call and output:

```{r sef_diet, eval = FALSE}
set.seed(581120)
diet_fit <- phylolm(sef ~ diet, data = spp_df, phy = tr,
                    model = 'lambda', boot = 2000)
```

I'm saving output for this fit because I'll be using that for summarizing.

```{r save_diet, eval = FALSE, purl = FALSE}
readr::write_rds(diet_fit, 'output/models_diet.rds')
```
```{r sef_diet_load, echo = FALSE, purl = FALSE}
diet_fit <- readr::read_rds('output/models_diet.rds')
```

Summary:

```{r diet_fit_summ}
summary(diet_fit)
```



# `Absorption` on `Taxon`

"Absorption" here means `Fractional absorption / (total intestinal surface)`,
where `total intestinal surface = NSA * SEF`


Necessary data:

```{r absorp_data}
absorp_df <- get_df('absorp')
absorp_tr <- get_tr('absorp')
```

`phylolm` call and output:

```{r absorp_taxon, eval = FALSE}
set.seed(454094511)
absorp_fit <- suppressWarnings(  # gives warning about lambda being very low
    phylolm(absorp ~ taxon + log_mass, data = absorp_df, phy = absorp_tr, 
            model = 'lambda', boot = 2000)
)
```


I'm saving output for this fit because I'll be using that for plotting.

```{r save_absorp, eval = FALSE, purl = FALSE}
readr::write_rds(absorp_fit, 'output/models_absorp.rds')
```

```{r absorp_load, echo = FALSE, purl = FALSE}
absorp_fit <- readr::read_rds('output/models_absorp.rds')
```

Summary:

```{r absorp_fit_summ}
summary(absorp_fit)
```



# `Morphometrics` on `Taxon`

List of `Morphometrics`:

- Intestinal length
- NSA
- Villus surface area
- Total number of enterocytes (log-transformed)
    * Calculated as such: `log(NSA * enterocyte_density)`

> log(body mass) as covariate for all

These are the column names for the above parameters:
```{r sp_analyses_cols}
spp_ys <- c("intestinal_length", "nsa", "vill_surface_area", "log_total_enterocytes")
```


Necessary data:
`spp_df` and `tr` are already created from fitting `sef ~ diet`.


`phylolm` call:

> The actual analyses (takes ~7.5 min, which is why I saved the output):

```{r sp_analyses, eval = FALSE}
set.seed(88754829)
spp_fits <- lapply(
    spp_ys,
    function(y) {
        f <- paste(y, '~ taxon + log_mass')
        suppressWarnings(
            do.call("phylolm", list(as.formula(f), data = as.name("spp_df"),
                                    phy = as.name("tr"), model = 'lambda',
                                    boot = 2000))
        )
    })
names(spp_fits) <- spp_ys
readr::write_rds(spp_fits, 'output/models_spp.rds')
```

Loading the output and summarizing:

```{r sp_analyses_load, purl = FALSE}
spp_fits <- readr::read_rds('output/models_spp.rds')
sapply(spp_fits, ci)
sapply(spp_fits, ci, 'log_mass')
```







# `Morphometrics` on `Taxon`, separately by segment


(Segment = proximal, medial, or distal)

List of `Y`s:

- Intestinal diameter (log-transformed, body mass as covariate)
- Villus height (body mass as covariate)
- Villus width
- Crypt width
- Surface enlargement factor (SEF)
- Enterocyte diameter
- Enterocytes per cm^2 NSA (log-transformed)




Below are the column names for these parameters and all the segment types.

```{r pos_ys}
pos_ys <- c('log_intestinal_diameter', 'villus_height', 'villus_width', 
            'crypt_width', 'sef', 'enterocyte_diameter', 'log_enterocyte_density')
seg_types <- c('prox', 'med', 'dist')
```


`phylolm` call:

The actual analyses (takes ~21.7 min, which is why I saved the output):

```{r pos_analyses, eval = FALSE}

for (pos in seg_types) assign(paste0(pos, '_df'), get_df('pos', .pos = pos))

mm <- map_df(
    seg_types,
    function(pos) {
        map_df(
            pos_ys,
            function(y) {
                arg_list1 <- list(
                    as.formula(paste(y, ' ~ taxon')),
                    data = as.name(paste0(pos, "_df")),
                    phy = as.name("tr"), model = 'lambda',
                    boot = 0)
                arg_list2 <- list(
                    as.formula(paste(y, ' ~ taxon + log_mass')),
                    data = as.name(paste0(pos, "_df")),
                    phy = as.name("tr"), model = 'lambda',
                    boot = 0)
                # These models don't find the peak likelihood unless specifying a
                # starting value of 0.1.
                if ((y == "log_enterocyte_density" & pos == "med") |
                    (y == "crypt_width" & pos == "prox")) {
                    arg_list1 <- c(arg_list1, starting.value = 0.1)
                    arg_list2 <- c(arg_list2, starting.value = 0.1)
                }
                # Now call phylolm
                suppressWarnings(
                    z1 <- do.call("phylolm", arg_list1))
                suppressWarnings(
                    z2 <- do.call("phylolm", arg_list2))
                aiccs <- map_dbl(list(z1, z2), aicc)
                data_frame(y, pos, daic = z1$aic - z2$aic, daicc = aicc(z1) - aicc(z2))
            })
})




# Negative means log_mass raises AIC --> don't use log_mass
mm %>% 
    arrange(y, pos) %>% 
    filter(y %in% c('sef', 'villus_width')) %>%
    as.data.frame

m = phylolm(villus_width ~ taxon + log_mass, med_df, phy = tr, 
            model = 'lambda', boot = 2000)
summary(m)
pval(m, 'log_mass')

# set.seed(25413535)
# pos_fits <- lapply(
#     seg_types,
#     function(pos) {
#         # Assigning to obj named <pos>_df so that the call identifies the position
#         assign(paste0(pos, '_df'), get_df('pos', .pos = pos))
#         lapply(
#             pos_ys,
#             function(y) {
#                 f <- paste(y, ' ~ taxon',
#                            ifelse(grepl('intestinal_diameter|villus_height', y),
#                                   '+ log_mass', ''))
#                 arg_list <- list(
#                     as.formula(f),
#                     data = as.name(paste0(pos, "_df")),
#                     phy = as.name("tr"), model = 'lambda',
#                     boot = 2000)
#                 # These models don't find the peak likelihood unless specifying a
#                 # starting value of 0.1.
#                 if ((y == "log_enterocyte_density" & pos == "med") |
#                     (y == "crypt_width" & pos == "prox")) {
#                     arg_list <- c(arg_list, starting.value = 0.1)
#                 }
#                 # Now call phylolm
#                 suppressWarnings(do.call("phylolm", arg_list))
#             })
#     })
# names(pos_fits) <- seg_types
# for (i in 1:length(pos_fits)) names(pos_fits[[i]]) <- pos_ys; rm(i)
# readr::write_rds(pos_fits, 'output/models_pos.rds')
```

Loading the output and summarizing:

```{r pos_analyses_load, purl = FALSE}
pos_fits <- readr::read_rds('output/models_pos.rds')
sapply(pos_fits$dist, ci)
sapply(pos_fits$med, ci)
sapply(pos_fits$prox, ci)
sapply(pos_fits$dist[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
sapply(pos_fits$med[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
sapply(pos_fits$prox[c('log_intestinal_diameter', 'villus_height')], 
       ci, parameter = 'log_mass')
```












# `Clearance` on `SEF`

Clearance = "paracellular probe L-arabinose clearance"

Both are log-transformed.

From the original manuscript: 
> ... we used reduced major axis regression (model II regression)... because both 
> variables [X and Y] were subject to error

Instead of an RMA regression, I'll be using a modified version of `ape::corphylo` 
to estimate Pearson correlation coefficients.
Confidence intervals are calculated using Fisher information.

```{r clear_sef}

clear_df <- get_df('clear')
clear_se_df <- get_df('clear', .stat = 'se')  # <-- contains standard errors
clear_tr <- get_tr('clear')

Xmat <- cbind(clear_df$log_sef, clear_df$log_clear)
rownames(Xmat) <- rownames(clear_df)

MEmat <- cbind(clear_se_df$log_sef, clear_se_df$log_clear)
rownames(MEmat) <- rownames(clear_se_df)

# # Using AIC, this doesn't need Umat for either parameter
# Xmat <- Xmat[!is.na(clear_df$log_mass),]
# MEmat <- MEmat[!is.na(clear_df$log_mass),]
# Umat <- list(NULL, cbind(clear_df$log_mass[!is.na(clear_df$log_mass)]))
# rownames(Umat[[2]]) <- rownames(Xmat)
# clear_tr_ <- ape::drop.tip(
#     clear_tr, 
#     tip = clear_tr$tip.label[!clear_tr$tip.label %in% rownames(Xmat)])

clear_sef <- corphylo_cpp(Xmat, phy = clear_tr, SeM = MEmat)

# Bootstrapping r (takes ~1 min)
set.seed(1844365955)
clear_sef_boot <- boot_r(clear_sef, 2000, n_cores = 4)
# p-value
2 * min(mean(clear_sef_boot > 0), mean(clear_sef_boot < 0))
# # Correcting for bias (not really necessary here)
# bias <- clear_sef$cor.matrix[1,2] - mean(clear_sef_boot)
# 2 * min(mean(clear_sef_boot + bias > 0), mean(clear_sef_boot + bias < 0))


hist(clear_sef_boot); abline(v = clear_sef$cor.matrix[1,2], lty = 2)
```


# `Clearance` on `log_enterocyte_density`


```{r clear_ed}

Xmat <- cbind(clear_df$log_enterocyte_density, clear_df$log_clear)
rownames(Xmat) <- rownames(clear_df)
Xmat <- Xmat[!is.na(rowSums(Xmat)),]

MEmat <- cbind(clear_se_df$log_enterocyte_density, clear_se_df$log_clear)
rownames(MEmat) <- rownames(clear_se_df)
MEmat <- MEmat[!is.na(rowSums(MEmat)),]

# # Using AIC, this doesn't need Umat for either parameter
# Umat <- list(cbind(clear_df$log_mass[!is.na(clear_df$log_mass)]), NULL)
# rownames(Umat[[1]]) <- rownames(Xmat)

clear_ed_tr <- ape::drop.tip(
    clear_tr, 
    tip = clear_tr$tip.label[!clear_tr$tip.label %in% rownames(Xmat)]
)

clear_ed <- corphylo_cpp(Xmat, phy = clear_ed_tr, SeM = MEmat)

# Bootstrapping r (takes ~1 min)
set.seed(1442148819)
clear_ed_boot <- boot_r(clear_ed, 2000, n_cores = 4)
# p-value
2 * min(mean(clear_ed_boot > 0), mean(clear_ed_boot < 0))
# # Correcting for bias (not really necessary here)
# bias <- clear_ed$cor.matrix[1,2] - mean(clear_ed_boot)
# 2 * min(mean(clear_ed_boot + bias > 0), mean(clear_ed_boot + bias < 0))

hist(clear_ed_boot); abline(v = clear_ed$cor.matrix[1,2], lty = 2)
```


# `Absorption` on `log_total_enterocytes`


```{r absorp_te}

absorp_df <- get_df('absorp')
absorp_se_df <- get_df('absorp', .stat = 'se')  # <-- contains standard errors
absorp_tr <- get_tr('absorp')


Xmat <- cp_mat(absorp_df, c('absorp', 'log_total_enterocytes'))
MEmat <- cp_mat(absorp_se_df, c('absorp', 'log_total_enterocytes'))
# # AIC indicates no Umat should be used (for either parameter)
# Umat <- list(NULL, cp_mat(absorp_df, 'log_mass'))

absorp_te <- corphylo_cpp(Xmat, phy = absorp_tr, SeM = MEmat)

# Bootstrapping r
set.seed(2016097648)
absorp_te_boot <- boot_r(absorp_te, 2000, n_cores = 4)
# p-value
2 * min(mean(absorp_te_boot > 0), mean(absorp_te_boot < 0))
# # Correcting for bias (not really necessary here)
# bias <- absorp_te$cor.matrix[1,2] - mean(absorp_te_boot)
# 2 * min(mean(absorp_te_boot + bias > 0), mean(absorp_te_boot + bias < 0))
hist(absorp_te_boot); abline(v = absorp_te$cor.matrix[1,2], lty = 2)


# Too few observations to use Umat when separating by taxon

Xmat <- cp_mat(absorp_df %>% filter(taxon == 'Bat'), 
               c('absorp', 'log_total_enterocytes'))
MEmat <- cp_mat(absorp_se_df %>% filter(taxon == 'Bat'), 
                c('absorp', 'log_total_enterocytes'))
nt <- filter_tr(absorp_tr, absorp_df$species[absorp_df$taxon == 'Bat'])
absorp_te_bat <- corphylo_cpp(Xmat, phy = nt, SeM = MEmat)

Xmat <- cp_mat(absorp_df %>% filter(taxon == 'Rodent'), 
               c('absorp', 'log_total_enterocytes'))
MEmat <- cp_mat(absorp_se_df %>% filter(taxon == 'Rodent'), 
                c('absorp', 'log_total_enterocytes'))
Umat <- list(cp_mat(absorp_df %>% filter(taxon == 'Rodent'), 'log_mass'), NULL)
nt <- filter_tr(absorp_tr, absorp_df$species[absorp_df$taxon == 'Rodent'])
absorp_te_rodent <- corphylo_cpp(Xmat, phy = nt, SeM = MEmat)


# Function to get r and r's (non-square-rooted) SE from corphylo object
r_se <- function(cp_obj) {
    r <- cp_obj$cor.matrix[1,2]
    n <- nrow(cp_obj$Vphy)
    se <- (1 - r^2) / (n - 2)
    return(cbind(r, se))
}


# Bootstrapping differnce in r
set.seed(217761492)
absorp_te_bat_boot <- boot_r(absorp_te_bat, 2000, n_cores = 4, boot_out = r_se)
absorp_te_rodent_boot <- boot_r(absorp_te_rodent, 2000, n_cores = 4, boot_out = r_se)
# Z scores
absorp_te_z <- (absorp_te_bat_boot[,'r'] - absorp_te_rodent_boot[,'r']) /
    sqrt(absorp_te_bat_boot[,'se'] + absorp_te_rodent_boot[,'se'])

# p-value
2 * min(mean(absorp_te_z > 0), mean(absorp_te_z < 0))

hist(absorp_te_z)
```




# Assembling all output into one object




I ran `ci_df` on all models above.
I also added the output from the correlation between `log_sef` and `log_clear` 
manually at the end, which I have to do because it isn't a `phylolm` object.


```{r mod_summaries, purl = FALSE}
mod_summaries <- bind_rows(
    list(
        ci_df(diet_fit),
        ci_df(absorp_fit),
        bind_rows(lapply(spp_fits, ci_df)),
        bind_rows(
            lapply(names(pos_fits), function(p) {
                bind_rows(lapply(pos_fits[[p]], ci_df, .pos = p))
            })),
        bind_cols(X = 'log_clear', Y = 'log_sef', clear_cor['r',])
        ))
```


I lastly write this summary to a csv file.


```{r write_summaries, purl = FALSE}
write_csv(mod_summaries, 'output/models_summaries.csv')
```




# Session info

This outlines the package versions I used for these analyses.

```{r session_info, echo = FALSE, purl = FALSE}
devtools::session_info()
```
