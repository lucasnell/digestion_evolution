---
title: "Phylogenetic linear regression"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
tz: "CST6CDT"
output:
  github_document:
    toc: true
    toc_depth: 2
---

```{r setup, include = FALSE, cache = FALSE, purl = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
```




Loading packages:


```{r load_packages}
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(purrr)
    library(phylolm)
    library(ape)
})
devtools::load_all('corphyloCpp')
```


# `source` the `R` directory

The `R` directory provides functions to summarize `phylolm` objects, run a version
of `ape::corphylo` with confidence interval output, and retrieve morphometric,
clearance, and absorption data.
See `tidy_csvs.md` for more info.

```{r source_R}
invisible(sapply(list.files('R', '*.R', full.names = TRUE), source))
```


The `get_tr` function in `R/get_data.R` reads the main phylogenetic tree, 
cleans species names, and removes unnecessary species from it for a given analysis set.

The function `ci` in `R/model_summaries.R` gets 95% CIs from a bootstrapped 
`phylolm` model object.

The function `ci_df` creates a tibble with 95% CIs for all parameters in a 
single model.


# `SEF` on `Diet`

Necessary data:

> The `spp_df` data frame is used for both this analysis and `Morphometrics` on `Taxon`.
> The `tr` tree is used for this analysis, `Morphometrics` on `Taxon`, and
> `Morphometrics` on `Taxon`, separately by segment.

```{r diet_data}
spp_df <- get_df('spp')
tr <- get_tr('spp')
```


`phylolm` call and output:

```{r sef_diet, eval = FALSE}
set.seed(581120)
diet_fit <- phylolm(sef ~ diet, data = spp_df, phy = tr,
                    model = 'lambda', boot = 2000)
```

I'm saving output for this fit because I'll be using that for summarizing.

```{r save_diet, eval = FALSE, purl = FALSE}
readr::write_rds(diet_fit, 'output/models_diet.rds')
```
```{r sef_diet_load, echo = FALSE, purl = FALSE}
diet_fit <- readr::read_rds('output/models_diet.rds')
```

Summary:

```{r diet_fit_summ, echo = FALSE}
for (p in c('dietOmnivorous', 'dietProtein')) {
    cat(sprintf('%s: %.4g (P = %.4g)\n', p,
                coef(diet_fit)[p], 
                pval(diet_fit, p)))
}
```



# `Absorption` on `Taxon`

"Absorption" here means `Fractional absorption / (total intestinal surface)`,
where `total intestinal surface = NSA * SEF`


Necessary data:

```{r absorp_data}
absorp_df <- get_df('absorp')
absorp_tr <- get_tr('absorp')
```

`phylolm` call and output:

```{r absorp_taxon, eval = FALSE}
set.seed(454094511)
absorp_fit <- suppressWarnings(  # gives warning about lambda being very low
    phylolm(absorp ~ taxon + log_mass, data = absorp_df, phy = absorp_tr, 
            model = 'lambda', boot = 2000)
)
```


I'm saving output for this fit because I'll be using that for plotting.

```{r save_absorp, eval = FALSE, purl = FALSE}
readr::write_rds(absorp_fit, 'output/models_absorp.rds')
```

```{r absorp_load, echo = FALSE, purl = FALSE}
absorp_fit <- readr::read_rds('output/models_absorp.rds')
```

Summary:

```{r absorp_fit_summ, echo = FALSE}
p <- 'taxonBat'
cat(sprintf('%s: %.4g (P = %.4g)\n', p,
                coef(absorp_fit)[p], 
                pval(absorp_fit, p)))
```



# `Morphometrics` on `Taxon`

List of `Morphometrics`:

- Intestinal length
- NSA
- Villus surface area
- Total number of enterocytes (log-transformed)
    * Calculated as such: `log(NSA * enterocyte_density)`

> log(body mass) as covariate for all

These are the column names for the above parameters:
```{r sp_analyses_cols}
spp_ys <- c("intestinal_length", "nsa", "vill_surface_area", "log_total_enterocytes")
```


Necessary data:
`spp_df` and `tr` are already created from fitting `sef ~ diet`.


`phylolm` call:

> The actual analyses (takes ~7.5 min, which is why I saved the output):

```{r sp_analyses, eval = FALSE}
set.seed(88754829)
spp_fits <- lapply(
    spp_ys,
    function(y) {
        f <- paste(y, '~ taxon + log_mass')
        suppressWarnings(
            do.call("phylolm", list(as.formula(f), data = as.name("spp_df"),
                                    phy = as.name("tr"), model = 'lambda',
                                    boot = 2000))
        )
    })
names(spp_fits) <- spp_ys
readr::write_rds(spp_fits, 'output/models_spp.rds')
```

Loading the output and summarizing:

```{r sp_analyses_load, purl = FALSE}
spp_fits <- readr::read_rds('output/models_spp.rds')
p <- 'taxonBat'
for (nn in names(spp_fits)) {
    cat(sprintf('Y = %s\n', nn))
    cat(sprintf('  %s: %.4g (P = %.4g)\n', p,
                    coef(spp_fits[[nn]])[p], 
                    pval(spp_fits[[nn]], p)))
}
```







# `Morphometrics` on `Taxon`, separately by segment


(Segment = proximal, medial, or distal)

List of `Y`s:

- Intestinal diameter (log-transformed, body mass as covariate)
- Villus height (body mass as covariate)
- Villus width
- Crypt width
- Surface enlargement factor (SEF)
- Enterocyte diameter
- Enterocytes per cm^2 NSA (log-transformed)




Below are the column names for these parameters and all the segment types.

```{r pos_ys}
pos_ys <- c('log_intestinal_diameter', 'villus_height', 'villus_width', 
            'crypt_width', 'sef', 'enterocyte_diameter', 'log_enterocyte_density')
seg_types <- c('prox', 'med', 'dist')
```


Below is a data frame including whether or not to include `log_mass` as a covariate.
This determination was based on whether `log_mass` had a significant effect when it was
included in the model, where p-values were based on parametric bootstrapping 
(see `docs/include_mass.md`).

```{r pos_log_mass_include, echo = FALSE}
include_mass <- rbind(
    # distal
    c('dist', 'log_intestinal_diameter', 0.000 < 0.05),
    c('dist', 'villus_height',           0.012 < 0.05),
    c('dist', 'villus_width',            0.193 < 0.05),
    c('dist', 'crypt_width',             0.500 < 0.05),
    c('dist', 'sef',                     0.283 < 0.05),
    c('dist', 'enterocyte_diameter',     0.782 < 0.05),
    c('dist', 'log_enterocyte_density',  0.462 < 0.05),
    
    # medial
    c('med', 'log_intestinal_diameter', 0.006 < 0.05),
    c('med', 'villus_height',           0.013 < 0.05),
    c('med', 'villus_width',            0.062 < 0.05),
    c('med', 'crypt_width',             0.379 < 0.05),
    c('med', 'sef',                     0.349 < 0.05),
    c('med', 'enterocyte_diameter',     0.621 < 0.05),
    c('med', 'log_enterocyte_density',  0.208 < 0.05),
    
    # proximal
    c('prox', 'log_intestinal_diameter', 0.000 < 0.05),
    c('prox', 'villus_height',           0.001 < 0.05),
    c('prox', 'villus_width',            0.009 < 0.05),
    c('prox', 'crypt_width',             0.881 < 0.05),
    c('prox', 'sef',                     0.024 < 0.05),
    c('prox', 'enterocyte_diameter',     0.823 < 0.05),
    c('prox', 'log_enterocyte_density',  0.203 < 0.05)) %>% 
    as_data_frame %>% 
    rename_(.dots = setNames(colnames(.), c('pos', 'y', 'include'))) %>% 
    mutate(include = as.logical(include))
include_mass
```




`phylolm` call:

The actual analyses (takes ~21.7 min, which is why I saved the output):

```{r pos_analyses, eval = FALSE}
set.seed(25413535)
pos_fits <- lapply(
    seg_types,
    function(pos) {
        # Assigning to obj named <pos>_df so that the call identifies the position
        assign(paste0(pos, '_df'), get_df('pos', .pos = pos))
        lapply(
            pos_ys,
            function(y) {
                f <- paste(y, ' ~ taxon')
                # Whether to include log_mass covariate
                imc <- {include_mass %>% filter(pos == pos, y == y)}$include
                if (imc[1]) f <- paste(f, '+ log_mass')
                arg_list <- list(
                    as.formula(f),
                    data = as.name(paste0(pos, "_df")),
                    phy = as.name("tr"), model = 'lambda')
                # Some models don't find the peak likelihood unless specifying a
                # starting value of 0.1.
                LL_nostart <- suppressWarnings(do.call("phylolm", arg_list))$logLik
                LL_wstart <- suppressWarnings(do.call(
                    "phylolm", c(arg_list, starting.value = 0.1)))$logLik
                if (LL_wstart > LL_nostart) {
                    arg_list <- c(arg_list, starting.value = 0.1)
                }
                arg_list <- c(arg_list, boot = 2000)
                # Now create the final phylolm object
                suppressWarnings(do.call("phylolm", arg_list))
            })
    })
names(pos_fits) <- seg_types
for (i in 1:length(pos_fits)) names(pos_fits[[i]]) <- pos_ys; rm(i)
readr::write_rds(pos_fits, 'output/models_pos.rds')
```

Loading the output and summarizing:

```{r pos_analyses_load, purl = FALSE}
pos_fits <- readr::read_rds('output/models_pos.rds')
cbind(sapply(pos_fits$dist, pval))
cbind(sapply(pos_fits$med, pval))
cbind(sapply(pos_fits$prox, pval))
```












# `Clearance` on `SEF`

Clearance = "paracellular probe L-arabinose clearance"

Both are log-transformed.

From the original manuscript: 
> ... we used reduced major axis regression (model II regression)... because both 
> variables [X and Y] were subject to error

Instead of an RMA regression, I'll be using a modified version of `ape::corphylo` 
that can conduct parametric bootstrapping.
P-values are calculated using these bootstrapping replicates.

```{r clear_sef}
clear_df <- get_df('clear')
clear_se_df <- get_df('clear', .stat = 'se')  # <-- contains standard errors
clear_tr <- get_tr('clear')

Xmat <- cp_mat(clear_df, c('log_sef', 'log_clear'))
MEmat <- cp_mat(clear_se_df, c('log_sef', 'log_clear'))

# Using p-values, this doesn't need Umat for either parameter

# corphylo_cpp run with bootstrapping (takes ~1 min)
set.seed(1844365955)
clear_sef <- corphylo_cpp(X = Xmat, phy = clear_tr, SeM = MEmat, boot = 2000, n_cores = 4)
clear_sef

# P-value for correlation != 0
pval(clear_sef)[1]
```


# `Clearance` on `log_enterocyte_density`

> One species (*Rattus norvegicus*) doesn't have `log_enterocyte_density` data, which
> is why I'm removing that row below.

```{r clear_ed}
Xmat <- cp_mat(clear_df, c('log_enterocyte_density', 'log_clear'))
Xmat <- Xmat[!is.na(rowSums(Xmat)),]

MEmat <- cp_mat(clear_se_df, c('log_enterocyte_density', 'log_clear'))
MEmat <- MEmat[!is.na(rowSums(MEmat)),]
# Using p-values, this doesn't need Umat for either parameter

clear_ed_tr <- ape::drop.tip(
    clear_tr, 
    tip = clear_tr$tip.label[!clear_tr$tip.label %in% rownames(Xmat)]
)

# Fit and bootstrap r (takes ~1 min)
set.seed(1442148819)
clear_ed <- corphylo_cpp(Xmat, phy = clear_ed_tr, SeM = MEmat, boot = 2000, n_cores = 4)

# P-value for correlation != 0
pval(clear_ed)[1]
```


# `Absorption` on `log_total_enterocytes`


```{r absorp_te}
absorp_df <- get_df('absorp')
absorp_se_df <- get_df('absorp', .stat = 'se')  # <-- contains standard errors
absorp_tr <- get_tr('absorp')

Xmat <- cp_mat(absorp_df, c('absorp', 'log_total_enterocytes'))
MEmat <- cp_mat(absorp_se_df, c('absorp', 'log_total_enterocytes'))
# Using p-values, this doesn't need Umat for either parameter

# Fit and bootstrap
set.seed(2016097648)
absorp_te <- corphylo_cpp(Xmat, phy = absorp_tr, SeM = MEmat, boot = 2000, n_cores = 4)

# P-value for correlation != 0
pval(absorp_te)[1]
```




# Assembling all output into one object


I ran `summ_df` on all models above.
This function summarizes `phylolm` and `corphylo` objects.


```{r mod_summaries, purl = FALSE}
mod_summaries <- bind_rows(
    list(
        summ_df(diet_fit),
        summ_df(absorp_fit),
        bind_rows(lapply(spp_fits, summ_df)),
        bind_rows(
            lapply(names(pos_fits), function(p) {
                bind_rows(lapply(pos_fits[[p]], summ_df, .pos = p))
            })),
        summ_df(clear_sef, .corr_pars = c('log_sef', 'log_clear')),
        summ_df(clear_ed, .corr_pars = c('log_enterocyte_density', 'log_clear')),
        summ_df(absorp_te, .corr_pars = c('absorp', 'log_total_enterocytes'))
        ))
```


I lastly write this summary to a csv file.


```{r write_summaries, purl = FALSE}
write_csv(mod_summaries, 'output/models_summaries.csv')
```




# Session info

This outlines the package versions I used for these analyses.

```{r session_info, echo = FALSE, purl = FALSE}
devtools::session_info()
```
