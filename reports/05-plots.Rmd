---
title: "Regression plots"
author: "Lucas Nell"
date: "`r Sys.setenv(TZ='America/Chicago'); format(Sys.Date(), '%d %b %Y')`"
output:
  github_document:
    toc: true
    toc_depth: 2
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE, cache = FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = normalizePath(".."))
# Useful if you keep getting `polygon edge not found` error
# From here: http://disq.us/t/24rt791
# options("device" = "quartz"); graphics.off()
```


```{r load_packages}
# Packages needed for this script
suppressPackageStartupMessages({
    library(readr)
    library(dplyr)
    library(tidyr)
    library(purrr)
    library(phylolm)
    library(ape)
    library(ggplot2)
    library(grid)
    library(gridExtra)
})
# Functions `get_df`, `get_tr`, `filter_tr`, `cp_mat`
source('R/get_data.R')
# Functions `pval`, `ci`, `summ_df`, `jack_phylolm`, and `predict_ci`
source('R/model_summaries.R')
# Custom version of ape::corphylo
suppressMessages(devtools::load_all('corphyloCpp'))

# setting default `ggplot2` theme
theme_set(theme_classic() %+replace% 
              theme(strip.background = element_blank(),
                    strip.text = element_text(size = 11, face = 'italic'),
                    legend.title = element_blank(),
                    legend.background = element_blank(),
                    plot.title = element_text(size = 14, hjust = 0)))
```


> Below, the `predict_ci` function creates a data frame of predictions and 95% CI from a 
> `phylolm` object.
> See its documentation in [`R/model_summaries.R`](R/model_summaries.R) 
> for more information.



# Loading model data


`phylolm` objects saved from [`04-phylo_fits`](04-phylo_fits.md):

```{r load_models}
models <- list(absorp = read_rds('output/models_absorp.rds'),
               pos = read_rds('output/models_pos.rds'),
               spp = read_rds('output/models_spp.rds'))
# I'm not plotting this one here
models$pos$prox$crypt_width_pagel <- NULL
```

Data frames used for each model fit:

> See [`../R/get_data.R`](../R/get_data.R) for what `get_df` does.

```{r load_data}
data <- list(absorp = get_df('absorp') %>% as_tibble,
             pos = lapply(c('prox','med', 'dist'), 
                          function(p) {get_df(.df = 'pos', .pos = p) %>% 
                                  mutate(pos = p)}) %>% 
                 bind_rows %>% 
                 as_tibble %>% 
                 select(pos, everything()) %>% 
                 gather('measure', 'value', -pos, -clade, -diet, -species, -log_mass) %>% 
                 mutate(pos = factor(pos, levels = c('prox','med', 'dist'), 
                                     labels = c('Proximal', 'Medial', 'Distal'))),
             spp = get_df('spp') %>% as_tibble,
             clear = get_df('clear') %>% as_tibble)
```



# Standardize plot titles

The below function adds titles to the top left corner of plots.

- `.p`: `ggplot` object to add the title to.
- `.title`: String to add as the plot title.
- `.mult`: List specifying multipliers for offset for x- and y-axes. Offsets are the
  amount of space from the upper-left corner of the plot the upper-left corner of 
  the title text.

```{r add_title_fxn}
add_title <- function(.p, .title, .mult = list(x = 1, y = 1), .data = NULL) {
    
    if (missing(.title)) stop("Why is .title missing?")
    if (is.null(.title)) return(.p)
    
    x_range <- ggplot_build(.p)$layout$panel_ranges[[1]]$x.range
    y_range <- ggplot_build(.p)$layout$panel_ranges[[1]]$y.range
    if (!is.null(.p$coordinates$trans$x)) {
        x_range <- .p$coordinates$trans$x$inverse(x_range)
    }
    if (!is.null(.p$coordinates$trans$y)) {
        y_range <- .p$coordinates$trans$y$inverse(y_range)
    }
    min_x <- min(x_range) + .mult$x * 0.02 * diff(x_range)
    max_y <- max(y_range) - .mult$y * 0.02 * diff(y_range)
    .p <- .p +
        geom_text(data = .data, 
                  label = .title,
                  x = min_x, y = max_y,
                  color = 'black',
                  hjust = 0, vjust = 1, 
                  size = 14 * (25.4/72), # <-- 25.4/72 is to convert from mm to pt
                  fontface = 'plain')
    return(.p)
}
```




# Individual plots for models by species only

## Function to create base plots

This creates the base plots for those models that have only clade on the x-axis
(i.e., those organized by species only—not by intestinal segment).
All these models include log(mass) as a covariate so are plotted with log(mass)
on the x-axis.


Function to create each plot depending on the `phylolm` model (`.model`),
y-axis title (`y_axis_title`),
plot title (`plot_title`),
y-axis break points (`y_breaks`),
y-axis labels (`y_labels`),
and y-axis limits (`y_limits`).
Only the first two are required.

```{r plots_spp_only_base}
clade_only_plot <- function(.model, 
                            y_axis_title, 
                            plot_title = NULL, 
                            y_breaks = ggplot2::waiver(), 
                            y_labels = ggplot2::waiver(), 
                            y_limits = NULL) {
    
    if (!'log_mass' %in% colnames(.model$X)) {
        stop("Model must include log(mass) as a covariate")
    }
    y_name <- {paste(.model$formula) %>% discard(~ grepl('~', .x))}[1]
    # Base plot
    .p <- predict_ci(.model) %>%
        # Exponentiate variables for plotting so we can more transparently
        # provide axis labels of the non-transformed numbers.
        # The same is done below when plotting the raw data.
        mutate_at(vars(log_mass, estimate, low, high), exp) %>% 
        ggplot(aes(log_mass, estimate, color = clade)) +
        # 95% CI envelopes
        geom_ribbon(aes(ymin = low, ymax = high, group = clade), 
                    fill = 'gray80', color = NA, alpha = 0.5) +
        # Raw data points
        geom_point(data = data_frame(estimate = as.numeric(.model$y), 
                                     log_mass = as.numeric(.model$X[,'log_mass']),
                                     clade = factor(as.integer(.model$X[,'cladeBat']), 
                                                    levels = c(0,1), 
                                                    labels = c('Rodent', 'Bat'))) %>%
                       mutate_at(vars(log_mass, estimate), exp),
                   size = 2) +
        # Regression fit
        geom_line() +
        theme(legend.position = 'none', legend.title = element_blank()) +
        # All these plots include log(mass) on the x-axis so I'm including this here.
        scale_x_continuous('Body mass (g)', trans = 'log', breaks = 10 * 4^(0:2),
                           limits = exp(c(2.043877, 5.199205)), expand = c(0,0)) +
        scale_y_continuous(y_axis_title, trans = 'log', breaks = y_breaks, 
                           labels = y_labels, limits = y_limits) +
        scale_color_manual(values = c('#9ecae1', '#de2d26'))
    
    # Add title if one is provided
    .p <- add_title(.p, plot_title)
    
    return(.p)
}
```

## Creating plot objects

For all the plots below...

1. Both axes are on the log scale.
2. Envelopes represent 95% CI for model predictions via parametric bootstrapping.


```{r plots_spp_only}
# Figure 1A
fig1a <- clade_only_plot(models$spp$log_intestinal_length,
                         "Intestinal length (cm)", 
                         y_breaks = 15 * 2^(0:2), 
                         plot_title = 'A') +
    theme(legend.position = c(0.05, 1), legend.justification = c(0, 1),
          axis.title.x = element_blank(), axis.text.x = element_blank())
# Figure 1B
fig1b <- clade_only_plot(models$spp$log_nsa,
                         expression("NSA (" * cm^2 * ")"), 
                         y_breaks = 5 * 2^(0:3), 
                         plot_title = 'B')
# Figure 4
fig4 <- clade_only_plot(models$spp$log_vill_surface_area,
                        expression("Villous surface area (" * cm^2 * ")"),
                        y_breaks = 50 * 3^(0:2)) +
    theme(legend.position = c(0.05, 1), legend.justification = c(0, 1))

# Figure 6
fig6 <- clade_only_plot(models$spp$log_total_enterocytes,
                        expression("Total enterocytes" %*% 10^{-9}),
                        # CHANGING UNITS HERE (from enterocytes to 
                        # 1e9 enterocytes:
                        y_breaks = 200e6 * 2^(0:3), y_labels = 0.2 * 2^(0:3)) +
    theme(legend.position = c(0.05, 1), legend.justification = c(0, 1))
```






# Individual plots for models by species and intestinal segment

## Objects to create base plots

Making data frame of confidence intervals.
(Nesting by parameter, not position, bc the former is how they'll be plotted.)

```{r plots_seg_ci}
pos_ci <- lapply(names(models$pos$prox), 
                 function(n) {
                     bind_rows(list(predict_ci(models$pos$prox[[n]]),
                                    predict_ci(models$pos$med[[n]]),
                                    predict_ci(models$pos$dist[[n]])))
                 }) %>% 
    bind_rows %>% 
    mutate(pos = factor(pos, levels = c('prox', 'med', 'dist'), 
                        labels = c('Proximal', 'Medial', 'Distal')))
```


Table of y-axis names for each parameter:

```{r plots_seg_names}
plot_names <- rbind(c("log_intestinal_diameter", "Intestinal ~ diameter ~ '(cm)'"),
                    c("log_villus_height", "Villus ~ height ~ '(mm)'"),
                    c("villus_width", "Villus ~ width ~ '(mm)'"),
                    c("crypt_width", "Crypt ~ width ~ '(mm)'"),
                    c("log_sef", "Surface ~ enlargement ~ factor ~ '(SEF)'"),
                    c("enterocyte_diameter", "Enterocyte ~ diameter ~ '(\u03BCm)'"),
                    c("log_enterocyte_density", 
                      "Enterocyte ~ density  %*% 10^{-6} ~ '(' * cm^{-2} * ')'")) %>% 
    as_tibble %>% 
    rename(og = V1, new = V2)
```


Function to create each plot depending on the input measurement name (`.measure`),
custom y-axis break points (`y_breaks`) and labels (`y_labels`),
and plot title (`plot_title`).

```{r plots_seg_fxn}
clade_pos_plot <- function(.measure, 
                           y_breaks = ggplot2::waiver(), 
                           y_labels = ggplot2::waiver(), 
                           plot_title = NULL) {
    # Getting model-prediction data frame for all three intestinal segments
    predict_df <- lapply(c('prox', 'med', 'dist'), 
                         function(seg_) {
                             df_ <- predict_ci(models$pos[[seg_]][[.measure]])
                             # Adding log_mass to models that don't include it
                             if (nrow(df_) == 2) {
                                 lm_ <- data$pos %>% 
                                     filter(grepl(seg_, pos, ignore.case = TRUE),
                                            measure == .measure)
                                 lm_ <- sapply(c('Bat', 'Rodent'),
                                               function(c_) {
                                                   range(lm_$log_mass[lm_$clade == c_])
                                               })
                                 df_ <- bind_rows(df_, df_) %>% 
                                     mutate(log_mass = c(t(lm_)),
                                            # signif = whether log(mass) was included 
                                            # in model (bc its P < 0.05)
                                            signif = 'no')
                             } else {
                                 df_ <- df_ %>% 
                                     mutate(signif = 'yes')
                             }
                             return(df_)
                         }) %>% 
        bind_rows %>% 
        mutate(signif = factor(signif, levels = c('no', 'yes')),
               pos = factor(pos, levels = c('prox', 'med', 'dist'), 
                            labels = c('Proximal', 'Medial', 'Distal')))
    
    # Is the y-axis log-transformed?
    y_logged <- grepl('log', .measure)

    # Exponentiating log(mass) so it's more transparent to create
    # axis labels on the non-transformed scale.
    # Doing this also for y variable if y_logged == TRUE
    if (y_logged) {
        predict_df <- predict_df %>% 
            mutate_at(vars(log_mass, estimate, low, high), exp)
        raw_data <- data$pos %>% 
            filter(measure == .measure) %>% 
            mutate_at(vars(log_mass, value), exp)
    } else {
        predict_df <- predict_df %>% 
            mutate_at(vars(log_mass), exp)
        raw_data <- data$pos %>% 
            filter(measure == .measure) %>% 
            mutate_at(vars(log_mass), exp)
    }
    
    # Provide y-axis breaks if none provided
    if (is(y_breaks, "waiver") & y_logged) {
        y_breaks <- predict_df %>% 
            summarize(min = min(low), max = max(high)) %>% 
            {seq(.$min, .$max, length.out = 4)} %>% 
            signif(digits = 3)
    }

    # y-axis transformation, depending on whether it's logged
    y_trans <- ifelse(y_logged, "log", "identity")
    
    # Title from `plot_names` data frame
    y_axis_title <- eval(parse(text = plot_names[plot_names$og == .measure,]$new))
    
    .p <- predict_df %>%
        ggplot(aes(log_mass, estimate, color = clade)) +
        geom_ribbon(aes(ymin = low, ymax = high, group = clade), 
                    fill = 'gray80', color = NA, alpha = 0.5) + 
        geom_line(aes(linetype = signif)) +
        geom_point(data = raw_data, aes(y = value), size = 2) +
        facet_wrap(~ pos) +
        scale_linetype_manual(values = c(2, 1), guide = FALSE, drop = FALSE) +
        scale_x_continuous('Body mass (g)', trans = 'log', breaks = 10 * 4^(0:2),
                           limits = exp(c(2.043877, 5.199205)), expand = c(0,0)) +
        scale_y_continuous(y_axis_title, trans = y_trans, breaks = y_breaks, 
                           labels = y_labels) +
        scale_color_manual(values = c('#9ecae1', '#de2d26')) +
        theme(legend.position = 'none', 
              axis.line = element_line(colour = "black", size = 0.5))
    
    # Add title if it's provided.
    # .mult is set to 3 for the x-axis to compensate for 3 facets
    # .data is provided to make sure it only shows up in the first facet
    .p <- add_title(.p, .title = plot_title, .mult = list(x = 3, y = 1),
                    .data = data_frame(pos = sort(unique(predict_df$pos))[1]))
    
    return (.p)
}
```


## Creating plot objects

X-axis is on log scale for all plots.

Y-axis is on log scale for all plots _except_ the following:

- fig2b
- fig2c
- fig5a


```{r plots_spp_pos}
# Figure 1c
fig1c <- clade_pos_plot('log_intestinal_diameter', y_breaks = 0.3 * 2^(0:2),
                        plot_title = 'C')

# Figure 2a
fig2a <- clade_pos_plot('log_villus_height', y_breaks = 0.2 * 2 ^(0:2),
                        plot_title = 'A') +
        theme(legend.position = 'top', legend.margin = margin(0,0,0,0),
              axis.text.x = element_blank(), axis.title.x = element_blank())

# Figure 2b
fig2b <- clade_pos_plot('villus_width', y_breaks = seq(0.04, 0.12, 0.04),
                        plot_title = 'B') +
    theme(axis.text.x = element_blank(), axis.title.x = element_blank(),
          strip.background = element_blank(), strip.text = element_blank())

# Figure 2c
fig2c <- clade_pos_plot('crypt_width', y_breaks = c(0.02, 0.04),
                        plot_title = 'C') + 
    theme(strip.background = element_blank(), strip.text = element_blank())

# figure 3
fig3 <- clade_pos_plot('log_sef', y_breaks = 5 * 2^(0:2)) +
    theme(legend.position = 'top')

# Figure 5a
fig5a <- clade_pos_plot('enterocyte_diameter',
               # CHANGING UNITS HERE (from mm to µm):
               y_breaks = seq(6e-3, 10e-3, 2e-3), y_labels = seq(6, 10, 2),
               plot_title = 'A') +
    theme(axis.text.x = element_blank(), axis.title.x = element_blank(),
          legend.position = 'top')

# Figure 5b
fig5b <- clade_pos_plot('log_enterocyte_density',
               # CHANGING UNITS HERE (from enterocytes / cm^2 to 
               # 1e6 enterocytes / cm^2):
               y_breaks = 8e6 * 3^(0:2), y_labels = 8 * 3^(0:2),
               plot_title = 'B') +
    theme(strip.background = element_blank(), strip.text = element_blank())
```



# Individual plots for clearance and absorption

All axes are on the log scale for all plots.

```{r plots_absorp_clear}
clear_label <- bquote(.("L-arabinose clearance (\u03BC") * 
                          l ~ min^{-1} ~ cm^{-2} * ")")
absorp_label <- bquote(.("Absorption") %*% 10^{3} ~ .("/ ") ~
                                .("intest. area (") * cm^{-2} * .(")"))

fig7a <- data$clear %>%
    mutate(sef = exp(log_sef), clear = exp(log_clear)) %>% 
    ggplot(aes(sef, clear, color = clade, shape = diet)) +
    geom_point(size = 3) +
    theme(legend.position = 'top',
          legend.title = element_text(size = 10, face = 'bold.italic'),
          legend.margin = margin(0,0,4,0),
          legend.justification = c(0, 0),
          legend.key.size = unit(0.75, 'lines')) +
    guides(color = guide_legend('Clade:', order = 1), shape = guide_legend('Diet:')) +
    scale_shape_manual(values = c(16, 17)) +
    scale_color_manual(values = c('#9ecae1', '#de2d26')) +
    scale_x_continuous("Surface enlagement factor (SEF)", 
                       trans = 'log', breaks = 8 * 1.5^(0:2)) +
    scale_y_continuous(clear_label,
                       trans = 'log', breaks = 1 * 3^(0:2))
fig7a <- fig7a %>%
    add_title('A')

# fig7b <- 
clade_only_plot(models$absorp,
                         y_axis_title = absorp_label,
                         plot_title = "B", 
                         # CHANGING UNITS HERE:
                         y_breaks = 0.001 * 4^(0:2), y_labels = 1 * 4^(0:2),
                         y_limits = c(7e-4, 0.02))

absorp_df2 <- left_join(data$absorp, data$spp, by = 'species', suffix = c('', '_X')) %>% 
    mutate(diet2 = factor(ifelse(diet == 'Protein', 'Protein', 'Carb'), 
                          levels = c('Carb', 'Protein'))) %>% 
    as.data.frame()
rownames(absorp_df2) <- absorp_df2$species

set.seed(1444134918)
abz <- phylolm(log_absorp ~ clade + diet2, 
        data = absorp_df2, model = 'lambda', phy = get_tr('absorp'),
        boot = 2000)
summary(abz)
pval(abz, c('cladeBat', 'diet2Protein'))

clear_df2 <- data$clear %>% 
    mutate(diet2 = factor(ifelse(diet == 'Protein', 'Protein', 'Carb'), 
                          levels = c('Carb', 'Protein'))) %>% 
    as.data.frame()
rownames(clear_df2) <- clear_df2$species

set.seed(1962960973)
clz <- phylolm(log_clear ~ clade + diet2, data = clear_df2, model = 'lambda', 
               phy = get_tr('clear'), boot = 2000)
summary(clz)
pval(clz, c('cladeBat', 'diet2Protein'))

Xmat <- cp_mat(get_df('absorp'), c('log_absorp', 'log_enterocyte_density'))
# Xmat <- Xmat[!is.na(rowSums(Xmat)),]
MEmat <- cp_mat(get_df('absorp', .stat = 'se'), c('log_absorp', 'log_enterocyte_density'))
# MEmat <- MEmat[!is.na(rowSums(MEmat)),]
Umat <- NULL
# Umat <- list(NULL, NULL)
# Umat[[1]] <- cbind(setNames(absorp_df2$log_mass, absorp_df2$species))
# Umat[[1]] <- cbind(Umat[[1]][!is.na(absorp_df2$log_enterocyte_density),])
# Umat[[2]] <- cbind(setNames(as.integer(absorp_df2$clade) - 1, absorp_df2$species))

left_join(data$clear, data$spp, by = 'species', suffix = c('', '_X')) %>% 
    filter(!is.na(log_mass)) %>% 
    ggplot(aes(log_total_enterocytes, log_clear, color = clade)) +
    geom_point()


cpmods <- read_rds('output/models_corphylo.rds')

cp = cpmods$clear_sef
mean_df = get_df('clear')
se_df = get_df('clear', .stat = 'se')
phy = get_tr('clear')
par_names = c('log_clear', 'log_sef')


i = 5
comp_ <- cp$cor.matrix[1,2]
# lapply(1:nrow(mean_df),
#        function(i) {
           
           Xmat_ <- cp_mat(mean_df[-i,], par_names)
           MEmat_ <- cp_mat(se_df[-i,], par_names)
           
           to_drop_ <- phy$tip.label
           to_drop_ <- to_drop_[!to_drop_ %in% rownames(Xmat_)]
           tr_ <- ape::drop.tip(phy, to_drop_)
           cp_ <- corphylo_cpp(Xmat_, phy = tr_, SeM = MEmat_, boot = 2000, n_cores = 4)
           cp_
           
           # return(c(infl = cp_$cor.matrix[1,2] - comp_))
    #    }) %>%
    # do.call(what = rbind) %>%
    # as_tibble








boot_fxn <- function(cp) {
    r = cp$cor.matrix[1,2]
    B = cp$B[!grepl('.0$', rownames(cp$B)),]
    rbind(c(R = r, B))
}

set.seed(2016097648)
# test_fit <- 
corphylo_cpp(Xmat, phy = get_tr('absorp'),
             SeM = MEmat, U = Umat, constrain.d = TRUE,
             boot = 2000, n_cores = 4)
test_fit
pval(test_fit)

apply(absorp_te$bootstrap, 2, quantile, probs = c(0.025, 0.975))
head(absorp_te$bootstrap)




models$absorp %>% 
    predict_ci() %>%
    # Exponentiate variables for plotting so we can more transparently
    # provide axis labels of the non-transformed numbers.
    # The same is done below when plotting the raw data.
    mutate_at(vars(log_mass, estimate, low, high), exp) %>% 
    ggplot(aes(log_mass, estimate, color = clade)) +
    # 95% CI envelopes
    geom_ribbon(aes(ymin = low, ymax = high, group = clade), 
                fill = 'gray80', color = NA, alpha = 0.5) +
    # Raw data points
    geom_point(data = data_frame(estimate = as.numeric(models$absorp$y), 
                                 log_mass = as.numeric(models$absorp$X[,'log_mass']),
                                 clade = factor(as.integer(models$absorp$X[,'cladeBat']), 
                                                levels = c(0,1), 
                                                labels = c('Rodent', 'Bat'))) %>%
                   mutate_at(vars(log_mass, estimate), exp),
               size = 2) +
    # Regression fit
    geom_line() +
    theme(legend.position = 'none', legend.title = element_blank()) +
    # All these plots include log(mass) on the x-axis so I'm including this here.
    scale_x_continuous('Body mass (g)', trans = 'log', breaks = 10 * 4^(0:2),
                       limits = exp(c(2.043877, 5.199205)), expand = c(0,0)) +
    scale_y_continuous(y_axis_title, trans = 'log', breaks = y_breaks, 
                       labels = y_labels, limits = y_limits) +
    scale_color_manual(values = c('#9ecae1', '#de2d26'))

# # Add title if one is provided
# .p <- add_title(.p, plot_title)

```

# Creating and saving final plots

## Function to combine plots

```{r final_plots_fxn}
# Combining multiple figures using the naming scheme `figX` where `X` is the 
# figure number I'm interested in plotting
# It also works for single figures.
one_fig <- function(fig_num, fig1_heights = c(7.9, 9, 10)) {
    grob_list <- lapply(ls(envir = .GlobalEnv)[grepl(paste0('^fig', fig_num), 
                                                     ls(envir = .GlobalEnv))], 
                        function(n) {
                            ggplotGrob(eval(parse(text = n)))
                        })
    if (fig_num == 1) {
        grid.draw(arrangeGrob(grobs = grob_list, ncol = 1, nrow = length(grob_list), 
                              heights = fig1_heights))
    } else if (fig_num %in% c(2, 5)) {
        grob_list <- lapply(grob_list, 
               function(gg) {
                   colnames(gg) <- paste0(seq_len(ncol(gg)))
                   return(gg)
               })
        grid.draw(do.call(gtable_rbind, grob_list))
    } else if (fig_num == 7) {
        grid.draw(do.call(rbind, c(grob_list[1:2], size = 'last')))
    } else {
        grid.draw(grob_list[[1]])
    }
    invisible()
}

# Employs the above function, plus saves the output
save_fig <- function(fig_num, fig1_heights = c(7.9, 9, 10), .seed = NULL, ...) {
    file_name <- sprintf('figs/fig%02d.pdf', fig_num)
    if (!is.null(.seed)) set.seed(.seed)
    quartz(type = 'pdf', file = file_name, family = 'Helvetica', ...)
    one_fig(fig_num, fig1_heights)
    invisible(dev.off())
}
```



```{r final_plots_creating}
save_fig(1, width = 3.875, height = 3.125 * 3, .seed = 1)
save_fig(2, width = 3.875, height = 3.125 * 3, .seed = 2)
save_fig(3, width = 3.875, height = 3.125, .seed = 3)
save_fig(4, width = 3.875, height = 3.125, .seed = 4)
save_fig(5, width = 3.875, height = 3.125 * 2, .seed = 5)
save_fig(6, width = 3.875, height = 3.125, .seed = 6)
save_fig(7, width = 3.125 * 2, height = 3.125 * 2, .seed = 7)
```




# Session info

This outlines the package versions I used for this script.

```{r session_info, echo = FALSE}
devtools::session_info()
```

